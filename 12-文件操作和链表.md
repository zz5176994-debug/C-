# 一、 文件操作
## 1.1 fopen函数

- **功能**：打开文件，并**返回指向该文件的指针**
- **原型**：
`fopen(const char *filename,const char *mode)`

参数说明：
    `filename`：待打开的文件名字符串，用绝对路径显示（表示绝对路径时用两个`\`其中一个为转义字符，另一个用来表示路径）
        文件名和路径名中允许有空格，如`fp=fopen("D:\\testfile\\GoodsInfo.txt","r");`


  `mode`：打开文件的模式
    下面是 `fopen()` 第二个参数（打开模式 mode）最常用、最实用的所有组合，一目了然 Markdown 表格（已按实际使用频率排序）：




| 模式字符串 | 含义说明                           | 是否可读 | 是否可写 | 文件不存在时 | 文件存在时行为          | 常见使用场景  |
|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
| `"r"`      | 只读打开文本文件                           | Yes      | 失败返回 NULL             | 从文件开头开始           | 读取配置文件、日志             |
| `"w"`      | 写入文本文件（覆盖）                       | No       | 创建新文件                | **截断为 0 长度**        | 写日志、导出数据、生成文件       |
| `"a"`      | 追加写入文本文件                           | No       | 创建新文件                | 指针放到文件末尾         | 写日志、记录运行轨迹             |
| `"r+"`     | 读写打开文本文件（不创建）                 | Yes      | 失败返回 NULL             | 从开头开始，可改写       | 修改已有配置文件、随机读写       |
| `"w+"`     | 读写打开（覆盖）                           | Yes      | 创建新文件                | **截断为 0 长度**        | 需要边写边读的临时文件           |
| `"a+"`     | 读 + 追加写                                | Yes      | 创建新文件                | 写操作始终追加到末尾，读可随意 | 日志文件既要读又要追加           |
| `"rb"`     | 只读打开**二进制**文件                     | Yes      | 失败返回 NULL             | 从开头                   | 读取图片、音频、exe 等           |
| `"wb"`     | 写入**二进制**文件（覆盖）                 | No       | 创建新文件                | 截断为 0                 | 保存图片、序列化数据             |
| `"ab"`     | 追加写入**二进制**文件                     | No       | 创建新文件                | 指针放到末尾             | 大文件分块追加                   |
| `"r+b"` 或 `"rb+"` | 读写**二进制**文件（不创建）       | Yes      | 失败返回 NULL             | 从开头，可随机读写       | 修改 PNG、MP4 等已存在二进制文件 |
| `"w+b"` 或 `"wb+"` | 读写**二进制**文件（覆盖）         | Yes      | 创建新文件                | 截断为 0                 | 创建并立即读写的二进制临时文件   |
| `"a+b"` 或 `"ab+"` | 读 + 追加写**二进制**文件          | Yes      | 创建新文件                | 写追加到末尾             | 二进制日志追加                   |


### 超级记忆口诀（背下来就再也不用查表了）

| 需求               | 用这个模式      |
|-------------------|-----------------|
| 纯读文本           | `"r"`           |
| 纯写（覆盖）       | `"w"`           |
| 纯追加             | `"a"`           |
| 读+写（不删文件）  | `"r+"`          |
| 读+写（先清空）    | `"w+"`          |
| 读+追加            | `"a+"`          |
| 二进制就加个 `b`   | `rb, wb, ab, r+b, w+b, a+b` |

### 特别提醒（踩坑必看）

- Windows 下处理文本文件如果不加 `b`，`\n` 会自动变成 `\r\n`，二进制文件务必加 `b`！
- `"w"` 和 `"w+"` 都会把原文件**直接删成 0 字节**，小心使用！
- `"a"` 和 `"a+"` 写操作永远追加到文件末尾，哪怕你 `fseek` 过也没用（标准规定如此）。
- C11/C99 之后还支持 `"x"` 系列（排他性创建），防止文件已存在时覆盖：
  - `"wx"`、`"w+x"`、`"wbx"` 等（Visual Studio 不一定支持）



## 1.2 feof函数
功能：检查给定文件的结尾，原型如下：
`int feof(FILE *stream)`，其中`stream`是指向文件的指针
如果读取到末尾，函数返回一个非0值；否则返回0值

```c
/* 把 D 盘 testfile 文件夹下的 GoodsInfo.txt 文件内容，一字不漏地显示在屏幕上。 */
#include<stdio.h>
int main(){
    FILE *fp;      // → 准备一个“文件遥控器”（名字叫 fp），以后用它来控制某个文件。
    int c;       // → 准备一个整数变量 c，专门用来临时存放从文件里读出来的“一个字符”。
    fp=fopen("D:\\testfile\\GoodsInfo.txt","r"); //→ 用遥控器去打开电脑里这个文件：
    if(fp==NULL){ // 如果打开失败，遥控器会等于 NULL（空）
        printf("Error in opening file");  // 就打印“打不开文件”
        return (-1);                     // 立刻结束程序，并告诉操作系统“我失败了”
    }
    while(1){    // 进入一个“死循环”，意思是一直重复下面的事
        c=fgetc(fp);  // 用遥控器从文件里“取下一个字符”，放进 c 变量里
        if(feof(fp)){  // 问遥控器：“文件已经读到结尾了吗？”
            break;    // 如果真的到结尾了，就跳出循环，结束读取
        }
        printf("%c",c);  // 把刚才抠出来的那个字符原样打印到屏幕上
    }
    fclose(fp);  // 读取完了，把文件关上（就像用完水龙头要关紧一样）
    return 0;  // → 程序正常结束
}
```

### 关于main函数的`return`：

|   写法    | 含义|    说明    |
|:-------:|:--:|:----------:|
|`return 0;`           |       成功|最常见、最清晰|
|`return 1;`           |       失败（具体值随意）|简单直接，足够了|
|`return EXIT_SUCCESS;`|成功|来自 <stdlib.h>，可移植性最好|
|`return EXIT_FAILURE;`|失败|同上，推荐在 `main `中使用|
|`return -1;`          |失败| 可以，但 -1 在某些系统被特殊处理，建议用 1|
|`return (-1);`        |失败（多余括号）|不要这么写！ 纯属画蛇添足|


### 类似的exit()函数
- 作用：直接结束整个程序

- 口诀：直接死亡，后面代码都不执行了！

- 对比`return 1;`和`exit(1);`

| 写法    |         在哪里用？       |效果     |
|:-----:|:--------------------:|:-------:|
|`return 1;`|只能在 main 函数里|结束 main，程序正常结束|
|`exit(1);`|任何地方都能用     |立刻强行终止整个程序（不管你在第几层函数）|

- ()里的数字叫 **退出状态码（exit status / return code）**，告诉操作系统（或者调用你程序的脚本）：“我是因为啥原因死的”。

|数字     |通用含义     |实际用法场景       |
|:-------:|:---------:|:-----------------:|
|`exit(0);`|成功！一切正常  |程序圆满完成任务|
|`exit(1);`|失败！有错误,最最最常用的“通用错误”|随便哪里出错都用这个|
|`exit(-1);`|失败（和 1 差不多）|很多老代码这么写，其实一样|
|`exit(127);`|命令未找到（shell 常用）|脚本里常用|
|`exit(EXIT_FAILURE);`|标准失败（推荐！）|包含 <stdlib.h> 后用，比 1 更专业|
|`exit(EXIT_SUCCESS);`|标准成功（推荐！）|等价于 0，更专业|

- 模板：

```c
if (malloc失败 || fopen失败 || 任何致命错误) {
    perror("错误原因");
    exit(EXIT_FAILURE);    // 一行解决，不留后患
}
```


## 1.3 fgetc函数
- **功能**：从已打开的文件里，一个一个地“抠”出字符来给你，每次只给你一个字符。
- **原型**：`int fgetc(FILE *stream);`,fgetc函数**返回值**必须是int , **参数**：一个 FILE* 文件指针
- C 语言规定：用一个特殊值 EOF 来表示文件结束。
而 EOF 在 <stdio.h> 里被定义成：

```c
#define EOF (-1)
```

也就是-1

| 返回值        |含义 |实际数值（一般    ）|
|:------:       |:---:|:-----------------:|
|0 ～ 255       |成功读取到一个字符（即使是空格、换行）|比如 'A' 是 65，'\n' 是 10|
|EOF（通常是 -1）|文件已经读到结尾或者出错了|-1|

- 经典模板：

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("test.txt", "r");
    if (fp == NULL) {
        perror("打开失败");
        return 1;
    }

    int c;                                   // 必须是 int！
    while ((c = fgetc(fp)) != EOF) {         // 经典中的经典写法
        putchar(c);                          // 或者 printf("%c", c);
    }

    fclose(fp);
    return 0;
}
```

## 1.4 fscanf函数
- **功能**：**从文件里**按你指定的“格式”一次读走一堆数据（可以是整数、浮点数、字符串等等）
它就是文件版的 scanf，只不过 scanf 从键盘读，fscanf 从文件读。
- **原型**：`int fscanf(FILE *stream, const char *format, ...);`
    - 第1个参数：文件指针（fopen 打开后得到的 fp）
    - 第2个参数：格式字符串（和 printf 一模一样）
    - 后面：你要把读到的数据存到哪里去（必须写地址！）
    - 返回值：成功读取并赋值的项目个数（非常重要！）

- **经典模板**：
假设有一个文件 `data.txt` 内容如下：

```text
张三 18 99.5
李四 20 87.0
王五 19 92.3
```

我们要一行一行读出 姓名、年龄、成绩：

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("data.txt", "r");
    if (fp == NULL) {
        perror("打开文件失败");
        return 1;
    }

    char name[20];
    int age;
    double score;

    // 经典循环写法：只要还能读到数据就继续,如果读到的数据不全，就停止
    while (fscanf(fp, "%s %d %lf", name, &age, &score) == 3) {
        printf("姓名：%s, 年龄：%d, 成绩：%.1f\n", name, age, score);
    }

    fclose(fp);
    return 0;
}
```

结果：

```text
姓名：张三, 年龄：18, 成绩：99.5
姓名：李四, 年龄：20, 成绩：87.0
姓名：王五, 年龄：19, 成绩：92.3
```


口诀：
>传文件指针 fp
>格式字符串和 printf 一模一样
>除了字符串，其余都要加 &
>用返回值判断是否读完（== 项目数）
>%s 永远加宽度限制防溢出！
## 1.5 fprintf函数
- **功能**：把你想打印的东西，按照指定格式，写到**任意文件里**去（而不是屏幕）
- **原型**：`int fprintf(FILE *stream, const char *format, ...);`
    - 第1个参数：文件指针（fopen 打开后得到的 fp）
    - 第2个参数：格式字符串（和 printf 完全一模一样！）
    - 后面：你要写入的数据

|函数	|写到哪里？|	经典用法|
|:------:|:--------:|:-------------:|
|`printf`|	屏幕（stdout）|`printf("Hello %d\n", x);`|
|`fprintf`|	任意文件	|`fprintf(fp, "Hello %d\n", x);`|
|`sprintf`|字符串	|`sprintf(str, "Hello %d", x);`|
|`snprintf`|	字符串（安全）|	`snprintf(str, sizeof(str), ...);`|


- 经典完整示例（99% 的文件写入代码都长这样）

```c
/* 假设我们要生成一个成绩表文件 result.txt： */
#include <stdio.h>

int main() {
    FILE *fp = fopen("成绩表.txt", "w");   // "w" 表示写入（没有就创建，有就清空）
    if (fp == NULL) {
        perror("创建文件失败");
        return 1;
    }

    // 写表头
    fprintf(fp, "姓名\t年龄\t成绩\n");
    fprintf(fp, "--------------------\n");

    // 写数据
    fprintf(fp, "%s\t%d\t%.1f\n", "张三", 18, 99.5);
    fprintf(fp, "%s\t%d\t%.1f\n", "李四", 20, 87.0);
    fprintf(fp, "%s\t%d\t%.1f\n", "王五", 19, 92.3);

    fclose(fp);
    printf("文件写入成功！\n");
    return 0;
}
```

运行后，文件`result.txt`的内容：

```text
姓名    年龄    成绩
--------------------
张三    18      99.5
李四    20      87.0
王五    19      92.3
```

## 1.6 malloc函数
- **功能**：在“堆”上给你申请一块你想要大小的内存，然后把这块内存的地址交给你用
就像你去酒店开房，前台（malloc）给你一把房卡（返回地址），房间多大（多少字节）由你说了算。
- **原型**：`void *malloc(size_t size);`
    - 参数：你要多少字节（**用 size_t 类型**，通常就是你要的字节数）
    - 返回值：成功 → 那块内存的首地址（void* 指针）
    - 失败 → 返回 NULL（内存不够用了！）

注意需要包含头文件：`#include <stdlib.h>`

- 经典完整示例（99% 的文件写入代码都长这样）

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("你要存几个整数？");
    scanf("%d", &n);

    // 申请 n 个整数的空间
    int *arr = malloc(n * sizeof(int));   // 关键！别忘了 sizeof

    if (arr == NULL) {
        printf("内存不够了！\n");
        return 1;
    }

    // 使用它就像普通数组一样
    for(int i = 0; i < n; i++) {
        arr[i] = i * 100;
        printf("%d ", arr[i]);
    }

    free(arr);           // 用完必须归还！否则内存泄漏
    arr = NULL;           // 防止野指针（超级好习惯）

    return 0;
}
```

输出：

`0 100 200 300 400`

- **口诀：**
malloc 三步走：
>malloc(个数 * sizeof(类型))
>`if (p == NULL) 失败处理
>free(p); p = NULL;

## 1.7 free函数
- **功能**：把你之前用 malloc / calloc / realloc 申请的堆内存“归还”给操作系统，让它可以再次被别人使用。
就像你住完酒店退房，必须把房卡（指针）还给前台（free），否则房间永远没人能住 → 内存泄漏！
- **原型**：`void free(void *ptr);`
    - 参数：你要释放的那块内存的首地址（就是 malloc 返回给你的那个指针）
    - 返回值：没有（void），成功失败都不告诉你
    - 头文件：`#include <stdlib.h>`

|铁律编号  |铁律内容|  违反后果    |
|:--------:|:-------:|:---------:|
|第1律     |只有 `malloc/calloc/realloc` 申请的才可以 `free`|崩溃、未定义行为|
|第2律|每一块内存只能 `free` 一次|二次 `free` → 崩溃（double free）|
|第3律|`free` 之后指针必须立刻设为 NULL|变成野指针，可能再次 free 或使用
|第4律|`free(NULL)` 是安全的（什么都不干）|——（这是唯一允许的“多free”）|


- 经典例子：

```c
int *arr = malloc(100 * sizeof(int));
if (arr == NULL) {
    perror("malloc failed");
    exit(1);//强制结束
}

// 使用 arr ...
arr[50] = 996;

// 释放三步曲（背下来！模板）
free(arr);     // 第1步：归还内存
arr = NULL;    // 第2步：立刻置空，防止野指针
// 第3步：以后再也不碰 arr
```

# 二、 链表

### 一、链表为什么存在？（一句话记住）
数组是连续的，插入删除太慢；  
链表是非连续的，用指针“手拉手”，插入删除快得飞起！

### 二、链表结点标准写法（背下来一辈子吃香）

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129212509755.png)

```c
typedef int ElemType;                     // 数据类型可以改成你想要的

typedef struct Node {
    ElemType      data;                   // 存数据
    struct Node  *next;                   // 指向下一个结点的指针
} Node;                                   // 结点类型名叫 Node
```

关键点：
- next 必须是指针！不能写成 struct Node next;（那才是真正的递归定义，会编译报错！）

### 三、链表的两种“头”写法（面试必考）

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129212836749.png)

| 方案               | 结构体定义                               | 头变量怎么声明         | 优点                               | 缺点                     |
|--------------------|------------------------------------------|------------------------|------------------------------------|--------------------------|
| 方案1：头指针法（最常用） | `typedef Node* List;`                      | `List L;`                | 简单，代码最少                     | 插入第一个结点时要特殊处理 |
| 方案2：带长度结构体 | `typedef struct { Node* head; int len; } List;` | `List L;`             | 随时知道长度，边界处理更简单       | 多占8字节                |

老师PPT里两种都讲了，推荐你先学会方案1（头指针法），90%的代码都这么写。

### 四、链表最核心的 6 个操作（永远记住这六个函数）

| 操作             | 关键代码（头指针法）                              | 时间复杂度 | 备注                                      |
|------------------|---------------------------------------------------|------------|-------------------------------------------|
| 创建新结点       | `Node* p = malloc(sizeof(Node));`                   | O(1)       | 永远第一步                                |
| 头插法           | `p->next = L;`  `L = p;`                          | O(1)       | 最快！倒着建表                            |
| 尾插法           | 遍历到最后一个，让 `last->next = p;` `p->next=NULL;`  | O(n)       | 正着建表                                  |
| 在pre后插入      | `p->next = pre->next;`  `pre->next = p; `             | O(1)       | 插入删除的核心！                          |
| 在pre后删除      | `Node* q = pre->next;`  `pre->next = q->next;` `free(q);` | O(1)     |                                           |
| 遍历打印         | `for(Node* p=L; p; p=p->next)` `printf("%d ",p->data);` | O(n)     |                                           |

### 五、定位“pre结点”的 4 种经典场景（老师重点讲的）

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213601203.png)



| 目标位置               | 怎么写代码（pre从L开始）                                                                 | 说明                               |
|------------------------|-------------------------------------------------------------------------------------------|------------------------------------|
| 1. pre是头结点         | pre = L;                                                                                  | 头插就用这个                       |
| 2. pre是尾结点         | while(pre->next) pre=pre->next;                                                           | 尾插时用                           |
| 3. pre是倒数第二个结点（删尾） | Node *pre = L, *p = L->next;<br>while(p->next){ pre=pre->next; p=p->next; }              | 快慢指针                           |
| 4. pre是第pos-1个位置  | Node *pre = L;<br>for(int k=1; k<pos && pre; k++) pre=pre->next;                          | 插入第pos个位置用                  |



![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213714441.png)

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213757271.png)

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213823603.png)

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213848234.png)

### 六、创建链表的两种最常用方法（老师PPT里都画了）

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213356088.png)

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/20251129213451841.png)

```c
// 方法1：头插法（结果是逆序（最常用！最快！）
Node* create_by_head_insert() {
    Node *L = NULL;
    int x;
    while(scanf("%d",&x), x!=9999) {      // 9999当结束标志
        Node* p = malloc(sizeof(Node));
        p->data = x;
        p->next = L;      // 插到最前面
        L = p;
    }
    return L;
}

// 方法2：尾插法结果是正序
Node* create_by_tail_insert() {
    Node dummy = {0, NULL};   // 虚拟头结点技巧
    Node* tail = &dummy;
    int x;
    while(scanf("%d",&x), x!=9999) {
        Node* p = malloc(sizeof(Node));
        p->data = x; p->next = NULL;
        tail->next = p;
        tail = p;
    }
    return dummy.next;   // 返回真正的头结点
}
```

### 七、销毁链表（防止内存泄漏！必须会！）

```c
void destroy(Node* L) {
    while(L) {
        Node* p = L;
        L = L->next;
        free(p);           // 先把当前结点删了，再往前走
    }
}
```

老师PPT里那段代码写错了！直接 free(L) 后再 L=L->next 会野指针崩溃！

### 八、老师反复强调的“边界情况”必须处理

| 情况                   | 必须检查/特殊处理的地方                                 |
|------------------------|----------------------------------------------------------|
| 空链表（L==NULL）      | 头插、尾插、删除时都要判断                               |
| 只有一个结点           | 删除、找尾结点时特别小心                                 |
| 插入位置非法（pos<1）| 插入前要判断越界                                         |
| 删除位置非法           | 同上                                                     |

### 九、完整标准模板（直接背下来，考试/面试随便写）

```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct Node {
    ElemType data;
    struct Node* next;
} Node;

// 创建新结点
Node* newNode(ElemType x) {
    Node* p = (Node*)malloc(sizeof(Node));
    p->data = x;
    p->next = NULL;
    return p;
}

// 头插
void push_front(Node** L, ElemType x) {
    Node* p = newNode(x);
    p->next = *L;
    *L = p;
}

// 尾插
void push_back(Node** L, ElemType x) {
    Node* p = newNode(x);
    if (*L == NULL) {
        *L = p;
        return;
    }
    Node* q = *L;
    while(q->next) q = q->next;
    q->next = p;
}

// 打印
void print(Node* L) {
    for(Node* p=L; p; p=p->next)
        printf("%d ", p->data);
    puts("");
}

// 销毁
void clear(Node** L) {
    Node* p = *L;
    while(p) {
        Node* q = p;
        p = p->next;
        free(q);
    }
    *L = NULL;
}

int main() {
    Node* L = NULL;
    for(int i=1; i<=5; i++) push_front(&L, i);
    print(L);        // 5 4 3 2 1
    clear(&L);
    return 0;
}
```

### 十、总结口诀（背下来这节课就满分）

```
链表不连续，用指针连，
next指向下家，最后是NULL，
malloc建结点，free别忘清，
头插最快来一套逆序行，
尾插正序走，虚拟头结点最稳，
pre，
pre找到就插，pre找到就删，
空表别忘判，一结点别漏！
```

现在你已经把老师这两节课（动态内存 + 链表）全部吃透了！

