# 10-字符串

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSusnpYp45HgyLPnZNpopGOfxd_jIRiMgmZhg&s)

## 一、 字符串常量
- 即定义在` " " `之间的字符序列

### 1.1. 

```c
# include<stdio.h>
int main(){
    char *a = "\"A graph consists of a set ofobjects,and set of relation between them.\"";
    printf("%s",a);
    /* %s可以用来输出以空白字符结尾的字符数组 */

    char subject[20] = "computer science";
    printf("%10.4s",subject);//也可以指定要输出字符数组的精度,输出结果：      comp (默认以右对齐的方式让前四个字符输出在宽度为10列的句段中)
    printf("%-10.4s",subject);//输出：comp       （加-就是左对齐）

    /* conclusion %m.ns */
    // .左边 m 表示字段宽度，当宽度小于字符串长度时，显示整个字符串
    // .右边 n 指定要显示的字符个数。若m省略不写，则表示 m=n
    // n = 0 时什么也不显示
    printf("%5s",subject);//输出：computer science
    printf("%16.0s",subject);//输出：无
    printf("%.3s",subject);//输出：com

    return 0;
}
```

- 字符串常量取下标操作的讲解与示例分析
 
代码解释
 
```c
char ch; ch = "subject"[1];
​
/*
- 在C语言里，字符串常量  "subject"  存储在内存中，它的首地址是一个指针。
​
- 当下标为  1  时，就是获取从首地址开始偏移  1  个位置的字符。
​
- 字符串  "subject"  中各个字符的下标（从0开始）依次为： s(0) 、 u(1) 、 b(2) 、 j(3) 、 e(4) 、 c(5) 、 t(6) ，所以  ch  被赋值为  'u' 。
*/
```

## 1.2. 转义序列
#### 1.2.1 概念  
转义序列提供了一种呈现如换行符（不可打印）等特殊符号的方法，转义序列共有两种
- 字符转义序列（字符转义序列使用起来很方便，但是没有包含所有不可打印的ASCII字符）

- 数字转义序列（数字转义序列可以表示任何字符，对特殊字符，数字转义序列使用这些字符的八进制或十六进制值）  


#### 1.2.2 🧩 C语言转义字符总结表

|  转义字符  | 含义                    | 说明              |
| :----: | :-------------------- | :-------------- |
|  `\n`  | 换行符 (newline)         | 光标移到下一行的开头      |
|  `\t`  | 水平制表符 (tab)           | 相当于按一次 Tab 键    |
|  `\r`  | 回车符 (carriage return) | 光标回到本行行首        |
|  `\b`  | 退格符 (backspace)       | 删除前一个字符         |
|  `\f`  | 换页符 (form feed)       | 打印机中换页          |
|  `\v`  | 垂直制表符 (vertical tab)  | 光标垂直跳到下一个制表位置   |
|  `\a`  | 响铃符 (alert)           | 发出提示音           |
|  `\\`  | 反斜杠本身 (`\`)           | 输出一个反斜杠         |
|  `\'`  | 单引号 (`'`)             | 输出 `'`          |
|  `\"`  | 双引号 (`"`)             | 输出 `"`          |
|  `\?`  | 问号 (`?`)              | 防止三字母词歧义        |
|  `\0`  | 空字符 (null)            | 字符串结束标志         |
| `\ddd` | 八进制字符                 | `ddd` 为1~3位八进制数 |
| `\xhh` | 十六进制字符                | `hh` 为1~2位十六进制数 |  

* 八进制转义序列由字符\和跟随其后的一个最多含有三位数字的八进制数组成，如\33或\033
* 十六进制转义序列由\x和跟随其后的一个十六进制数组成如\x1b或\x1B。其中x必须小写，十六进制的数字不限大小写

---  
#### 1.2.3 转义序列的使用
- 作为字符常量使用时，转义序列必须用一对单引号括起来
例如:`一个用转义序列表示的字符常量可以写成'\33'或'\x1b'`
- 直接使用转义序列的代码可读性差，所以采用#define的方式给它们命名
`#define ESC'33'`
- 转义序列也可以嵌入在字符串中使用
`printf("%s”，"abc\a\b\ta\n");`  
- 八进制转义序列的格式是` \ `后紧跟1到3个八进制数字（0 - 7）,如`\033`(其代表的ASCII码值就是八进制数033对应的十进制数27)  
- char 类型的变量只能存储一个字符（转义字符作为一个整体，代表一个字符）


## 二、 字符串变量
### 2.1 存储形式和初始化

```c
/* 存储 */
#define STR_LEN 80
char location[STR_LEN + 1]  //用字符数组表示字符串
/* 
当编译器把字符串赋值给字符数组时，会自动在字符数组的末尾添加空白字符'\0'
因此写成 STR_LEN + 1 强调location字符数组最多可存储80个字符
同时注意空白字符 '\0' 与零字符 '0' 不一样，前者ASCII值是0，后者48
*/

/* 2种初始化 */
// ①
char subject[5] = "math";

// ②元素列举
char subject[5] = {'m','a','t','h','\0'};  // 最后必须加终止字符'\0'
//要注意声明和初始化不能分开，下面是个错误示范：
char subject[5];
subject = "math";/* 错误 */
/* 对于初始化时的数组长度：
① 可以不指定
② 可以把数组长度声明得比字符个数更大（多余的初始化为空字符）
*/ 
char location[]={'c','h','e','n','g','d','u','\0'}
char subject[7] = "math";
```

subject数组名被编译器作为`char *const`类型的指针来对待

```c

// ① 字符数组是“常指针”，不能做“左值”
char s1[4]="abc";
char s2[4];
s2 = s1;  /* 错误 */

// ② 不能改变指针常量
char *p="math";
*p = 'a';/* 错误 */

// ③ 可以改变字符变量
char s[10]="math";
char *p=s;
*p = 'a';
```

## 三、 字符串的读和写
### 3.1 写
#### 3.1.1 printf
在 1.1 部分已做介绍
- 但在Unix系统环境下的printf函数有另一个很好的特性，
- 即允许字段宽度和精确度是变量，示例如下：

```c
char *subject = "Computer Science";
printf("%*.*s\n",w,d,subject);//两个*就是变量
//表示在宽度为w的字段中显示字符串的前d个字符
```

- 对应例题

```c
/* 编写一个程序computer.c,逐一输出“Computer”字符串的所有字符 */
#include<stdio.h>
int main(void){
    char subject[9]="Computer";

    //正序
    for(int i=0;i<9;i++){
        printf("%-16.*s\n",i,subject);
    }

    //逆序
    for(int j=8;j>=1;j--){
        printf("%-16.*s\n",j,subject);
    }
    return 0;
}
```

结果
> C
> Co
> Com
> Comp
> Compu
> Comput
> Compute
> Computer
> Computer
> Compute
> Comput
> Compu
> Comp
> om
> Co
> C
#### 3.1.2 putchar
`putchar(ch);` putchar函数的参数只能是一个字符
- 但是还有另一个方便的方法：**puts函数**（库函数，在头文件stdio.h中被定义）
`puts(str);` 参数是字符串变量

```c
char subject[] = "Computer Science";
puts(subject);
```

### 3.2 读
#### 3.2.1 scanf函数
```c
char location[9];
scanf("%s",location);//字符数组名本质上就是数组的首地址，所以读取字符串时不需要加&

//当然可以指定字段宽度
scanf("%6s",location);//6表示读入字符数的上限
```

- 缺陷：函数一旦遇到空白字符（包括空格符、制表符、回车符、样式缩进、换行符），就会终止输入

#### 3.2.2 getchar函数
`ch = getchar();` getchar函数不带参数，且每次只读一个字符
- **返回值是int**
- 相应的，也有**gets_s函数**（库函数，在头文件stdio.h中被定义）

```c
/* gets_s函数示例 */
#define len 6
//在该程序中，所输入的字符串的长度不能大于5
int main(){
    char str[len];
    gets_s(str,len);//调用，第一个参数是字符串变量，第二个参数是为缓冲区的大小，获取字符串时超出所定义的的缓冲区的部分将被丢弃
    /* gets函数会一直读取直到换行符，然后丢弃这个换行符，将空白字符加到字符串变量中 */
    printf("%s",str);
}
```

- 练习：编写程序，实现对字符串的复制，并计算所复制的字符串的长度

```c
/* duplicate.c */
#include<stdio.h>
#include<stdlib.h>
#define STR_LEN 80
void main(){
    char string1[STR_LEN+1],string2[STR_LEN+1];
    int i;
    printf("Please input the string:\n");
    scanf("%s",string2);
    for(i=0;string2[i] != '0';i++){
        string1[i] = string2[i];
    }
    string1[i] = '0';
    printf("%s\n",string1);
    printf("The length of character is %d\n",i);
}
```

结果：
>Please input the string:
>abcdef
>abcdef
>The length of character is 6

## 四、字符的算术运算

**4.1. 判断是否为ch大写字母**
`ch >= 'A' && ch <= 'Z'`

**4.2. 将字符数字转换成相应的整数**

```c
char str = '5';
int x=str-'0';//变量x输出5 
```


  * 可以用atoi函数

```c
char num[5]="2019";
int x = atoi(num);
```

- 练习：以十进制数和字符的形式显示字母a ~ z和A ~ Z

```c
/* alphabet.c */
#include<stdio.h>
#include<stdlib.h>
void main(){
    char c;
    for(c=65;c<=122;c++){
        if(c>90 && c<97)//跳过91~96的不是字母的符号,Z-90,a-97
          continue;
        printf("|%4d - %c",c,c);
    }
    printf("\n");
}

```

结果：
>|  65 - A|  66 - B|  67 - C|  68 - D|  69 - E|  70 - F|  71 - G|  72 - H|  73 - I|  74 - J|  75 - K|  76 - L|  77 - M|  78 - N|  79 - O|  80 - P|  81 - Q|  82 - R|  83 - S|  84 - T|  85 - U|  86 - V|  87 - W|  88 - X|  89 - Y|  90 - Z|  97 - a|  98 - b|  99 - c| 100 - d| 101 - e| 102 - f| 103 - g| 104 - h| 105 - i| 106 - j| 107 - k| 108 - l| 109 - m| 110 - n| 111 - o| 112 - p| 113 - q| 114 - r| 115 - s| 116 - t| 117 - u| 118 - v| 119 - w| 120 - x| 121 - y| 122 - z

## 五、字符串处理函数
都在string.h头文件中`#include<string.h>`

| 函数名     | 功能说明                         | 典型原型                                    | 返回值 | 注意事项 |
|------------|----------------------------------|---------------------------------------------|--------|----------|
| `strcpy`     | 将源字符串复制到目标字符串       | char *strcpy(char *dest, const char *src);  | dest   | 目标空间必须足够大；会复制 '\0' |
| `strlen`     | 计算字符串长度（不含 '\0'）      | size_t strlen(const char *s);               | 长度   | 停在第一个 '\0'；不能传 NULL |
| `strcat`     | 将源字符串拼接到目标字符串后面   | char *strcat(char *dest, const char *src);  | dest   | 目标必须有足够空间；尾部 '\0' 需保留 |
| `strcmp`     | 比较两个字符串大小               | int strcmp(const char *s1, const char *s2); | <0/0/>0 | 从左到右比较；按ASCII码差值返回 |


### 5.1 `strcpy`函数 
#### 5.1.1 示例

```c
char city[10],city2[20];
strcpy(city,"Chengdu");//第二个参数可以是字符数组或者字符串常量

//strcpy函数的返回值是指向目标字符串（前一个参数）的指针，可以把strcpy函数连起来调用
strcpy(city2,strcpy(city,"Chengdu"));
//之后city2与city的值均为"Chengdu"
```

#### 5.1.2 安全版本(`strncpy`)
- 缺点：速度慢
- 不同点：多一个参数，用于限制所复制的字符数

```c
strncpy(str1,str2,sizeof(str1)-1);
str1[sizeof(str1)-1] = '\0';//确保str1总是以空白字符结束
```

### 5.2 `strlen`函数
计算字符串中字符数，但是不包含空白字符
- 示例：

```c
char str1[20];
strcpy(str1,"cat");
len = strlen(str1);   /* slen为3 */
/* 当用字符数组作为实际参数时，strlen函数返回的是存储在数组中的字符串长度，而不是数组本身的长度 */
```

### 5.3 `strcat`函数
#### 5.3.1 示例

```c
char str1[20];str2[20];
strcpy(str1,"abc");
strcat(str1,"def");//把两个字符串拼接在一起
//str1包含"abcdef"
```

#### 5.3.2 安全版本(`strncat`)
- 缺点：速度慢
- 不同点：多一个参数，用于限制所复制的字符数

```c
strncat(strq,str2,sizeof(str1)-strlen(str1)-1);
```


### 5.4 `strcmp`函数
- 原型：`int strcmp(const char *s1,const char *s2);`
返回一个小于、大于或等于0的值，例如，为了检验str1是否小于str2,可以写成`if(strcmp(str1,str2)<0)`
- 一般满足如下两个条件，**str1小于str2成立**
    1. str1与str2前i个字符一致，但是str1的i+1个字符小于str2的第i+1个字符`"abc"<"bcd" ; "xyy"<"xyz"`
    2. str1与str2所有字符一致，但是str1比str2短,如`"abc"<"abcd"`

### 5.5 ASCII字符集的规律
1. A~Z,a~z,0~9的ASCII值是连续的
2. 所有大写字母的ASCII值（65~90）都小于小写字母ASCII值（97~122）
3. 数字的ASCII值（48~57）小于字母的ASCII值
4. 空格符的ASCII值（32）小于所有输出字符的ASCII值

### 5.6 练习：编写日历

```c
/* calendar.c */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_MEMO 60  //最大备忘条目数
#define MSG_LEN 80   //每条备忘条目的最大长度

/* 用于读取用户输入的字符串 */
int get_a_string(char str[],int n){
    int ch,i = 0;
    while((ch = getchar()) != '\n')//读取字符直到换行
      if(i < n)   //限制长度不超过n
        str[i++] = ch;
    str[i] = '\0';  //手动添加字符串结束符
    return i;  //返回实际读取的字符数
}

/* main函数 */
int main(){
/* 1. 变量定义 */
    char calendar[MAX_MEMO][MSG_LEN + 3];//二维数组存所有备忘录（每行一条）
    char day_part[3],msg_part[MSG_LEN + 1];//day_part接收日期,msg_part接收备忘内容
    int day,i,j,num_memo = 0;//day是输入的日期，num_memo是当前已存的备忘录数量

/* 2. 循环输入（无限循环，直到输入0或存满） */
for(; ;){
    if(num_memo == MAX_MEMO){
        printf("no space left!\n");
        break;
        }  //存满60条则提示并退出
    printf("input day and memo:");
    scanf("%2d",&day);//读取日期（最多两位，如38，5）
    if(day == 0)
      break;

    sprintf(day_part,"%2d",day);//把日期转成2位字符串（比如3 -> "3",12 -> "12"）
    get_a_string(msg_part,MSG_LEN); //读取备忘内容（允许带空格）


/* 3. 按日期排序插入 */
//步骤1：找到当前日期应该插入的位置i
for(i = 0;i < num_memo;i++){
    if(strcmp(day_part,calendar[i])<0)
    break;//找到比当前日期大的位置，插入到它前面
}
//步骤2：把i之后的元素往后挪一位，腾出位置
for(j=num_memo;j > i;j--){
    strcpy(calendar[j],calendar[j-1]);//后移
}
//步骤3：把当前日期+内容拼接到calendar[i]
strcpy(calendar[i],day_part);//先存日期
strcat(calendar[i],msg_part);//再拼接备忘内容
num_memo++;//已存数量+1
}

/* 4. 输出所有备忘录 */
printf("\nDay Memo\n");
for(i=0;i<num_memo;i++)
   printf("%s\n",calendar[i]);
}
```

结果：
>input day and memo:12 abc
>input day and memo:13 cde
>input day and memo:0
>Day Memo
>12 abc
>13 cde

## 六、 字符串的惯用法

- 主要学习思路，在很多地方都能用到这种思维方法

### 6.1 搜索字符串末尾

- strlen函数就是一个典型，
- 基本思想 ：逐个访问字符串的字符，并判断是否达到末尾，在这个过程中计数器不断累加

```c
/* strlen.c */
size_t strlen(const char *s){
    int n;
    for(n=0 ;*s!='\0'; n++)
       s++;
    return n;
}
```  


显然会有很多简化版本

```c
/* strlen2.c */
// ① 把n的初始化移到函数的声明中
size_t strlen(const char *s){
    int n = 0;//
    for(;*s!='\0'; n++)
       s++;
    return n;
}

// ② *s!='\0'与*s!=0等同，测试*s!=0与测试*s一样，两者在*s不为0时结果为真
size_t strlen(const char *s){
    int n = 0;
    for(;*s; n++)//
       n++;//
    return n;
}

// ③ 可以在同一个表达式中对s进行自增操作且测试*s
size_t strlen(const char *s){
    size_t n = 0;
    for(;*s++;)//
       n++;
    return n;
}

// ④ 用while替换for
size_t strlen(const char *s){
    size_t n = 0;
    while(*s++)
       n++;
    return n;
}

// ⑤ 两指针相减所得为它们之间元素数，只需找到空白字符地址后，减去字符串起始地址

size_t strlen(const char *s){
    char *p = s;
    while(*s)
       s++;
    return s-p;
}

```

### 6.2 字符串的复制

```c
/* strcat.c */
char *strcat(char *s1,const char *s2){
    char *p=s1;
    while(*p!='\0')
         p++;  //确定s1指向的字符串的末尾空白字符的位置，并使p指向它
    while(*s2!='\0'){
        *p=*s2;
        p++;
        s2++;
    }  //把s2指向的字符串的字符逐个复制到所指向的位置
    *p='\0';
    return s1;
}
```

- 类似于对strlen的处理，也可以对strcat进行简化

```c
/* strcat2.c */
char *strcat(char *s1,const char *s2){
    char *p=s1;
    while(*p) //与*p!='\0'等价
         p++; 
    while(*p++=*s2++) //赋值的同时直接对指针进行运算
        ;
    return s1;
}
/* 上述代码为何没有单独用一条语句在新的字符串后面加空白字符？
因为：判断条件是赋值表达式，所以while语句会先赋值再测试，也就是测试复制的字符是否为0。
当复制到“空白字符”时， while 判断条件会变成“假”，循环直接终止，是在赋值后终止 */
```


## 七、 字符串数组

- 思考 :thinking:如何存储某班学生的姓名列表、公司职员的姓名列表等？

```c
/* ① 创建二维的字符数组 */
char city[][11]={"Beijing","Shanghai","Suzhou","Xian","Chengdu"};
//缺点：低效，浪费空间

/* ② 用指针数组 */
char *city[]={"Beijing","Shanghai","Suzhou","Xian","Chengdu"};

//例题：在city中搜寻以字母X开头的字符串
for(int i=0;i<5;i++){
    if(city[i][0]=='X')
      printf("%s begins with X\n",city[i])
}
```

## 八、 总结字符串/字符判断函数
**一张超级清晰的总结表**

全部来自 `<ctype.h>` 头文件，记得 `#include <ctype.h>`

| 函数名          | 返回值类型 | 判断什么？                       | 返回 true 的例子                 | 返回 false 的例子         | 经典用途                              |
|:-----------------:|:------------:|:----------------------------------:|:----------------------------------:|:----------------------------:|:---------------------------------------:|
| `isalnum(c)`      | `int`        | 是字母或数字吗？                 | `'A','7','z'`                      | `' ','!','\n'`               | 检查密码强度、用户名合法性            |
| `isalpha(c)`      | `int`        | 是字母吗？（a-z A-Z）            | `'G','k'`                          | `'5','@',' '`                | 凯撒加密里“只加密字母”               |
| `isdigit(c)`      | `int`        | 是十进制数字吗？（0-9）          | `'0'~'9'`                          | `'a',' ','-'`                | 读入字符串转整数时判断                |
| `isxdigit(c)`     | `int`        | 是十六进制数字吗？（0-9 a-f A-F）| `'A','f','5'`                      | `'g','z'`                    | 解析颜色代码 #FF8800                  |
| `islower(c)`      | `int`        | 是小写字母吗？                   | `'a'~'z'`                          | `'A','5'`                    | 转大写前判断                          |
| `isupper(c)`      | `int`        | 是大写字母吗？                   | `'A'~'Z'`                          | `'a','3'`                    | 转小写前判断                          |
| `isspace(c)`      | `int`        | 是空白字符吗？                   | `空格、\t、\n、\r、\f、\v`         | `'a','1'`                    | 跳过输入中的空格、去前后空白          |
| `isblank(c)`      | `int`        | 是空格或制表符吗？（C99）         | `' ','\t'`                         | `'\n'`                       | 处理 CSV、单词分割时常用              |
| `iscntrl(c)`      | `int`        | 是控制字符吗？（ASCII 0-31,127） | `'\n','\0', DEL`                   | `'A',' '`                    | 过滤不可打印字符                      |
| `isgraph(c)`      | `int`        | 是有可见字符吗？（不包括空格）   | `'A','1','!'`                      | `' ','\n','\0'`              | 判断是否有“看得见的字符”              |
| `isprint(c)`      | `int`        | 是可打印字符吗？（包括空格）     | `'A',' ','~'`                      | `'\n','\0'`                  | 判断能否直接打印                      |
| `ispunct(c)`      | `int`        | 是标点符号吗？（不是字母数字空格）| `'!','.',','`                      | `'A','7',' '`                | 解析表达式、分割单词                  |

### 超级实用组合记忆法（背5个就全都会）

| 场景                     | 用哪个组合？                         | 例子                                  |
|--------------------------|--------------------------------------|---------------------------------------|
| 只处理字母               | `isalpha(c)`                           | 凯撒加密                              |
| 只处理数字               | `isdigit(c)`                           | 字符串转整数                          |
| 跳过所有空白            | `isspace(c)`                           | 读入一整行后去掉前后空格              |
| 判断是否是字母或数字     | `isalnum(c)`                           | 用户名、变量名合法性检查              |
| 判断是否是可见字符       | `isgraph(c)`                           | 密码不能为空格                        |
| 判断能否直接打印         | `isprint(c)`                           | 日志输出过滤控制字符                  |

### 转换函数（顺便背下来，经常和判断一起用）

| 函数         | 作用                     | 示例                       |
|--------------|--------------------------|----------------------------|
| `tolower(c)`   | 转小写                   | `tolower('G') → 'g'`         |
| `toupper(c)`   | 转大写                   | `toupper('b') → 'B'`         |

### 经典代码模板（直接抄走）

```c
#include <ctype.h>
#include <stdio.h>

int main() {
    char s[] = "Hello123! \t\n";
    for (int i = 0; s[i]; i++) {
        if (isalpha(s[i]))   printf("字母 ");
        else if (isdigit(s[i])) printf("数字 ");
        else if (isspace(s[i]))  printf("空白 ");
        else if (ispunct(s[i])) printf("标点 ");
        printf("%c\n", s[i]);
    }
}
```

### 终极记忆口诀（背下来再也不忘！）

> alpha 字母，digit 数字，  
> lower 小写，upper 大写，  
> space 空白全家桶，  
> alnum 字母加数字，  
> punct 标点不带空格，  
> print 能打，graph 能看！




