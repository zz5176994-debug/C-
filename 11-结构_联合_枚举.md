
- c语言主要有两大数据类型
标量类型：只含有单个数据项的类型 
聚合类型：含有多个数据项的类型

## 一、结构
- 是一个多变量的集合，与数组的区别： 结构的成员可能具有不同的类型
### 1.1 对结构的声明和初始化
#### 1.1.1 声明
有两种方法：**①** 直接声明
           **②** 如果需要在不同位置对成员一致的结构进行声明，就应该定义表示结构类型（而不是结构变量）的名字

```c
/* 一、直接 */
struct{
    int number;              /* 学生学号 */
    char name[NAME_LEN+1];  /* 学生姓名 */
    int age;                /* 学生年龄 */
}student1,student2;/*指明了类型（但是目前这个类型是没有名字的），
                而student1,student2是具有这种结构类型的变量，
                又因为student1,student2的类型没有名字，所以不能把这类结构用做函数调用的参数和函数的返回值 */
struct{
    int id;                 /* 教师工号 */
    char name[NAME_LEN+1];  /* 教师姓名 */
    int age;               /* 教师年龄 */
}teacher1;

int age;                   /* 普通变量 */
                         /* 一个结构代表一个新的作用域，任何声明在结构中的名字都不会和结构的其他名字冲突 */


/* 二、 定义表示结构类型的名字 
   ①声明结构标记
   ②使用typedef关键字来定义结构类型名 */
//①
struct Student{  //声明了名为Student的结构类型
    int number;
    char name[NAME_LEN+1];
    int age;
};  //注意，右花括号后的分号必不可少  ，一旦创建了结构标记Student，就可以用它来结合关键字struct来声明结构变量了，如下：
struct Student student1,student2;//Student是结构标记，前面没有struct就毫无意义，所以它不会和程序中用到的其他名字发生冲突，程序中拥有名为Student的普通变量是完全合法的

结构标记的声明和结构变量的声明可以合在一起
struct Student{ 
    int number;
    char name[NAME_LEN+1];
    int age;
}student1,student2;//所有声明为struct Student类型的结构都是兼容的，可以进行赋值运算
student1 = student2;

//②
typedef struct{
    int number;
    char name[NAME_LEN+1];
    int age;
}Student;//注意，类型Student必须出现在定义的末尾，而不是struct的后面，我们可以像内置类型一样使用Student,如可以用它声明变量：
Student student1,student2;//Student必须独立使用，不能在前面加struct
/* 定义结构类型的方法两种均可，
但当结构用于链表时，必须使用声明结构标记，
因为在链表中定义结构类型时，在结构内有一个指向相同结构类型的指针成员，这个成员用来指向下一个结点，在这种情况下无法使用typedef关键字 */


```

#### 1.1.2 初始化
- 与数组类似，可以在声明的同时进行初始化，并且**初始化式**里的成员数可以少于初始化的**结构**中的成员数
- 初始化有两种方法：

    1. 根据成员顺序直接给出
    2. 指定初始化式

1. 示例一

```c
struct{
    int number;              
    char name[NAME_LEN+1];  
    int age;              
}student1={1,"Bob",18};
```

2. 示例二：

```c
struct{
    int number;              
    char name[NAME_LEN+1];  
    int age;              
}student1={.number=1,.name="Bob",.age=18};
```


* 该方法的优点在于：

    * 方便阅读且容易验证
    * 初始化式中的值不需要与结构中的成员顺序保持一致
    * 指定初始化式中列出的值的前面不一定要有指示符`.`,如`.number=1,"Bob",.age=18`（值"Bob"的前面没有指示符，所以编译器会认为它用于初始化结构中位于number之后的成员）



### 1.2 对结构的操作

- 两种主要操作

    1. 选择成员

        - 两种成员选择运算符：`.`和`->`，且两者优先级相同，但`.`的优先级高于`&`(`sacnf("%d",&student1.age)`)计算的是`student1.age`的地址
        - `.`的应用格式为`结构变量名.成员名`
        - `->`的应用格式为`指向结构变量的指针->成员名`

    2. 对成员赋值

        1. 结构的成员是左值，可以出现在=左侧或自增/减（`.`的优先级与后缀`++`和后缀`--`一样）

        ```c
        student1.number=2;
        student1.age++;
        ```

        2. 另外一种赋值方法：用`=`把一个结构的所有成员的值赋给与之兼容的结构，`student2=student1;`
        （值得一提的是：结构中的数组成员也能通过这种方式实现数组的复制，但是数组本身不能用`=`进行赋值）

        ```c
        struct{
            int array[10];
        }a1,b1={{1,2,3,4,5}};
        a1=b1;

        ```

        还需注意：不能用`==`和`!=`来判断两个结构是否相等



## 二、 结构类型
### 2.1 定义结构类型


















---
尚未整理

# 程序结构 

### 作用域（scope）
- 变量的作用域系指该变量生效的范围。
- 在范围内，变量对其后的所有程序实体可见的(visible)，是可访问的(accessible) 
- 在此范围之外(之前、之后)变量对其他程序实体是不可见的(invisible)、不可访问的（inaccessible)。  
### 存储期  
- 指保持该变量的存储的最短潜在生命周期  
  
| 存储期            | 存储在何地，何时分配和释放                                                                 |
|-------------------|--------------------------------------------------------------------------------------------|
| 自动的 (automatic) | 在块开始时分配，块结束时释放。存储在栈（stack）中                                          |
| 静态的 (static)    | 存储在程序开始时分配，程序结束时释放。存储在**全局数据区**中                                   |
| 分配的 (allocated) | 存储是显式动态申请和释放的。存储在堆（heap）中                                             |
| 线程的 (thread)    | 存储在线程开始时分配，线程结束时释放                                                      |  
  

### 存储类别（storage class）
| 关键字      | 示例            | 变量的存储期   | 可以修饰                     |
|-------------|------------------|----------------|------------------------------|
| auto        | auto int i;      | automatic      | 局部变量，排除形参          |
| register    | register int i;  | automatic      | 局部变量和形参              |
| static      | static int i;    | static         | 局部和全局变量，排除形参    |
| extern      | extern int i;    | static         | 全局变量                    |


### 具有自动存储期的变量
| 声明 / 定义在哪里                                      | 作用域                       | 生命周期                                           |
|--------------------------------------------------------|------------------------------|---------------------------------------------------|
| 所有定义在一对 `{ }` 之间、没有用 `static` 修饰的变量 | 自其定义处至该块结束        | 退出该作用域时变量失效                           |
| 函数的形式参数                                         | 该函数的函数体              | 函数调用开始到函数返回，函数结束后参数失效       |
| `for` 语句初始化部分定义的变量                        | 该条 `for` 语句的语句块内   | `for` 循环结束时，该变量失效                     |  

### 具有静态存储期的变量  


| 分类                 | 特征内容                                                                 |
|----------------------|--------------------------------------------------------------------------|
| **静态的局部变量**   | - 定义在 `{}` 内部<br> - 使用 `static` 关键字修饰，如 `static int i = 0;`（一般需初始化）<br> - 仅初始化一次，若未显式初始化，按0初始化<br> - 生命周期为整个程序运行期间<br> - 保留上一次的计算结果，直到被再次修改 |
| **静态的非局部变量** | - 定义在所有函数之外，也称为全局变量<br> - 可加或不加 `static` 修饰<br> - 从定义处开始，对其后的所有代码可见<br> - 若某个函数修改了该变量，其改变对所有函数生效 |  

```c
/*var-static.c*/  

```  

![](./img/mask.jpg) 

### 链接属性 (Linkage)

| 链接属性 (Linkage)     | 显现形式 (Where It Appears)                        | 备注 (说明)                                               |
|-------------------------|----------------------------------------------------|-----------------------------------------------------------|
| 未设置 (none)           | - 局部变量（包括静态局部变量）<br> - 函数形参      | - 仅在定义它的代码块中可见和使用                         |
| 内部的 (internal)       | - `static` 修饰的全局变量<br> - `static` 修饰的函数 | - 仅在本源文件中可用<br> - 若在其他源文件访问将导致链接错误 |
| 外部的 (external)       | - `extern` 修饰的全局变量<br> - `extern` 修饰的函数 | - 可以被其他源文件访问和使用（具有外部链接性）           |  

| 性质       | 可见范围              | 常见修饰符       | 举例                  |
| -------- | ----------------- | ----------- | ------------------- |
| none     | 当前块 `{}` 内        | 无           | 函数内定义的变量            |
| internal | 当前源文件 `.c/.cpp` 内 | `static`    | `static int x = 0;` |
| external | 可跨源文件访问           | `extern`、默认 | 全局变量、非 static 函数    |  

### 堆栈

![](./img/堆栈.jpg)  

- 压栈:`void push(int i);`   
- 弹栈：`int pop();`   
- 判栈满：`bool is_full();` 
- 判栈空：`bool is_empty();`

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// 定义栈最大深度
#define STACK_SIZE 100

// 用一维数组模拟栈的存储
int contents[STACK_SIZE];
// 栈顶指针
int top = 0;

/**
 * @brief 栈溢出，退出程序
 */
void stack_overflow() {
    printf("Stack Overflow\n");
    exit(EXIT_FAILURE);
}

/**
 * @brief 栈空，退出程序
 */
void stack_underflow() {
    printf("Stack is empty\n");
    exit(EXIT_FAILURE);
}

/**
 * @brief 判断栈是否满
 * @return true 栈满
 * @return false 栈未满
 */
bool is_full() {
    return top == STACK_SIZE; 
}

/**
 * @brief 判断栈是否空
 * @return true 栈空
 * @return false 栈未空
 */
bool is_empty() {
    return top == 0;
}

/**
 * @brief 压栈
 * @param i 待压栈的元素
 */
void push(int i) {
    if (is_full())    // 如果栈满
        stack_overflow();
    else
        contents[top++] = i;
}

/**
 * @brief 弹栈
 * @return int 弹出的元素
 */
int pop() {
    if (is_empty())   // 如果栈空
        stack_underflow();
    else
        return contents[--top];
}

/**
 * @brief 测试函数
 */
int main() {
    for (int i = 0; i < 5; ++i) 
        push(i);    // 压栈 0,1,2,3,4

    int v = pop();   // 弹出4
    printf("%d, %d\n", v, pop()); // 输出 4, 3

    return 0;
}
``` 

```c
// 常规字符串字面常量
printf("To be or not to be, it's a question.");
```