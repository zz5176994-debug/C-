
- c语言主要有两大数据类型
标量类型：只含有单个数据项的类型 
聚合类型：含有多个数据项的类型

# 结构

## 一、结构
- 是一个多变量的集合，与数组的区别： 结构的成员可能具有不同的类型
### 1.1 对结构的声明和初始化
#### 1.1.1 声明
有两种方法：**①** 直接声明
           **②** 如果需要在不同位置对成员一致的结构进行声明，就应该定义表示结构类型（而不是结构变量）的名字

```c
/* 一、直接 */
struct{
    int number;              /* 学生学号 */
    char name[NAME_LEN+1];  /* 学生姓名 */
    int age;                /* 学生年龄 */
}student1,student2;/*指明了类型（但是目前这个类型是没有名字的），
                而student1,student2是具有这种结构类型的变量，
                又因为student1,student2的类型没有名字，所以不能把这类结构用做函数调用的参数和函数的返回值 */
struct{
    int id;                 /* 教师工号 */
    char name[NAME_LEN+1];  /* 教师姓名 */
    int age;               /* 教师年龄 */
}teacher1;

int age;                   /* 普通变量 */
                         /* 一个结构代表一个新的作用域，任何声明在结构中的名字都不会和结构的其他名字冲突 */


/* 二、 定义表示结构类型的名字 
   ①声明结构标记
   ②使用typedef关键字来定义结构类型名 */
//①
struct Student{  //声明了名为Student的结构类型
    int number;
    char name[NAME_LEN+1];
    int age;
};  //注意，右花括号后的分号必不可少  ，一旦创建了结构标记Student，就可以用它来结合关键字struct来声明结构变量了，如下：
struct Student student1,student2;//Student是结构标记，前面没有struct就毫无意义，所以它不会和程序中用到的其他名字发生冲突，程序中拥有名为Student的普通变量是完全合法的，声明了结构变量student1,student2

结构标记的声明和结构变量的声明可以合在一起
struct Student{ 
    int number;
    char name[NAME_LEN+1];
    int age;
}student1,student2;//所有声明为struct Student类型的结构都是兼容的，可以进行赋值运算
student1 = student2;

//②
typedef struct{
    int number;
    char name[NAME_LEN+1];
    int age;
}Student;//注意，类型Student必须出现在定义的末尾，而不是struct的后面，我们可以像内置类型一样使用Student,如可以用它声明变量：
Student student1,student2;//Student必须独立使用，不能在前面加struct
/* 定义结构类型的方法两种均可，
但当结构用于链表时，必须使用声明结构标记，
因为在链表中定义结构类型时，在结构内有一个指向相同结构类型的指针成员，这个成员用来指向下一个结点，在这种情况下无法使用typedef关键字 */


```

#### 1.1.2 初始化
- 与数组类似，可以在声明的同时进行初始化，并且**初始化式**里的成员数可以少于初始化的**结构**中的成员数
- 初始化有两种方法：

    1. 根据成员顺序直接给出
    2. 指定初始化式

1. 示例一

```c
struct{
    int number;              
    char name[NAME_LEN+1];  
    int age;              
}student1={1,"Bob",18};
```

2. 示例二：

```c
struct{
    int number;              
    char name[NAME_LEN+1];  
    int age;              
}student1={.number=1,.name="Bob",.age=18};
```


* 该方法的优点在于：

    * 方便阅读且容易验证
    * 初始化式中的值不需要与结构中的成员顺序保持一致
    * 指定初始化式中列出的值的前面不一定要有指示符`.`,如`.number=1,"Bob",.age=18`（值"Bob"的前面没有指示符，所以编译器会认为它用于初始化结构中位于number之后的成员）



### 1.2 对结构的操作

- 两种主要操作

    1. 选择成员

        - 两种成员选择运算符：`.`和`->`，且两者优先级相同，但`.`的优先级高于`&`(`sacnf("%d",&student1.age)`)计算的是`student1.age`的地址
        - `.`的应用格式为`结构变量名.成员名`
        - `->`的应用格式为`指向结构变量的指针->成员名`

    2. 对成员赋值

        1. 结构的成员是左值，可以出现在=左侧或自增/减（`.`的优先级与后缀`++`和后缀`--`一样）

        ```c
        student1.number=2;
        student1.age++;
        ```

        2. 另外一种赋值方法：用`=`把一个结构的所有成员的值赋给与之兼容的结构，`student2=student1;`
        （值得一提的是：结构中的数组成员也能通过这种方式实现数组的复制，但是数组本身不能用`=`进行赋值）

        ```c
        struct{
            int array[10];
        }a1,b1={{1,2,3,4,5}};
        a1=b1;

        ```

        还需注意：不能用`==`和`!=`来判断两个结构是否相等



## 二、 结构类型
### 2.1 定义结构类型

即在1.1.1中介绍的两种：

1. 声明结构标记
2. 使用typedef关键字来定义结构类型名

### 2.2 在函数中使用结构
结构类型的**变量**可以作为函数的参数和返回值
1. **作为参数**

```c
/* print_student.c,显示出struct Student结构类型变量的成员值 */
void print_student(struct Student st){//其中struct Student是结构变量，st是结构变量
    printf("student number:%d\n",st.number);
    printf("student name:%s\n",st.name);
    printf("student age:%d\n",st.age);
}
```

可以对所有的`struct Student`结构类型变量调用函数来查看成员值
`print_student(student1);`

2. **作为返回值**

```c
/* build_student,创造一个新的结构类型变量并将其初始化 */
struct Student build_student(int number,const char* name,int age){
    struct Student st;
    st.number=number;
    strcpy(st.name,name);
    st.age=age;
    return st;
}
```

- 函数build_student的形式参数名和结构Student的成员名相同是合法的，因为结构有自己的名字空间
- 结构作为参数和返回值，和普通变量一样，都是通过值来传递。因此给函数传递值时，要**复制结构中所有成员**，加大了程序开销

- 下面介绍一种效率更高的常见的作法：**用指向结构的指针来进行函数的相关操作**

    1. 定义一个指向struct Student结构类型的指针
    `struct Student *struct_pointer;`
    2. 该**指针变量**可以存储**结构变量**的地址：
    `struct_pointer=&student1;`
    3. 用`->`可访问该结构中的成员：
    `struct_pointer->number;`

- 用该做法改写上面两个函数

```c
/* print_student2.c 显示出struct Student结构类型变量的成员值 */
void print_student(struct Student *st){
    printf("student number:%d\n",st->number);
    printf("student name:%s\n",st->name);
    printf("student age:%d\n",st->age);
}

/* build_student2,创造一个新的结构类型变量并将其初始化 */
struct Student* build_student(int number,const char* name,int age){
    struct Student *st;
    st=(struct Student *)malloc(sizeof(struct Student));
    st->number=number;
    strcpy(st->name,name);
    st->age=age;
    return st;
}
```

### 2.3 复合字面量（实时创建结构）
- 生成的结构可做函数的**返回值**，可**像参数一样传递**，可以**赋值给变量**
- 下面展示两个例子：
    1. 使用复合字面量创建一个结构，这个结构将被传递给函数
    `print_student((struct Student){1,"Bob",18});`
    结构分析:圆括号里面是类型名（①结构标记前加上struct;②typedef），花括号里面是一组值
    2. 把复合字面量赋值给变量
    `struct Student student1=(struct Student){1,"Bob",18};`

## 三、 数组和结构的嵌套
### 3.1 结构的嵌套

依旧上面的例子，如果要在结构中添加学生生日的年月日，虽然可以直接加成员，但如果要打印生日，需传三个参数，更好的方法是将**学生生日的年月日作为一个新的结构**

```c
struct student_birth{
    int year;
    int month;
    int day;
};

//把这个结构作为学生信息结构中的成员
struct Student{ 
    int number;
    char name[10];
    int age;
    struct student_birth birthday;
}student1,student2;

```

访问嵌套在结构中的结构的成员时需要两次用到`.`，从左至右联级：`student1.birthday.year=1996;`

### 3.2 结构数组(元素是结构的数组)
定义和初始化如下：

```c
struct Student students[4]={
    [0]={.number=1,.name="Bob",.age=18},
    [1]={.number=2,.name="Alice",.age=18},
    [2]={.number=3,.name="Scott",.age=18},
    [3]={.number=4,.name="Jack",.age=19}
};
```

c99指定初始化
`struct Student students[100]={[0].number=4,[0].name="Jack",.age=19};`


---


# 联合
**联合也是由一个或多个不同类型的变量组成**
**与结构不同的是：它允许在相同的存储位置存储不同数据类型的成员**
**内存空间的大小取决于占用内存空间最大的成员**
**联合的成员在这个空间内彼此覆盖，给一个成员赋新值也会改变其他成员的值**
**所以任何时候只能有一个成员起作用**

## 一、 联合的声明+初始化+操作
- 与结构一样样的

1. 声明

```c
union{
    int i;
    float f;
    char str[10];
}data;
```

data中，成员i，f，str占用的内存如下，它们具有相同的首地址

![](https://cdn.jsdelivr.net/gh/zz5176994-debug/images@main/pic/IMG_20251127_212727.jpg)


2. 操作——访问成员
`data.i=20;`
3. 初始化
与结构不同的是：初始化时联合只有第一个成员可以获得初始值

```c
union{
    int i;
    float f;
    char str[10];
}data={0};

/* 可以指定要初始化哪一个成员 */
union{
    int i;
    float f;
    char str[10];
}data1={.f=12.3};
```



## 二、 联合的应用
### 应用一：节约空间
要设计的结构包括**学校成员（老师和学生）的信息**，每个成员的信息包括年龄，姓名，**学生学号/老师工号**，**学生成绩/老师授课编号**

- 初级版本(只用结构)：

```c
struct person{
    int age;
    char name[NAME_LEN+1];
    int person_type;//标记字段——用来提示存储在联合中的内容（详见三、 联合的标记字段），值将是student或teacher

    //学生专有
    int student_number;
    int grade;

    //老师专有
    int teacher_number;
    int class_number;
};
```

缺点：学生不需要存储`teacher_number`和`class_number`

- 改良版：在结构person内部放置联合

```c
struct person{
    int age;
    char name[NAME_LEN+1];
    int person_type;//值将是student或teacher

    union{
        struct{
            int student_number;
            int grade;
        }student;

        struct{
            int teacher_number;
            int class_number;
        }teacher;
    }per;//联合名
}c;//c是结构名
```

如果c是表示学生的person结构,可用如下方法显示学生学号：
`printf("%d\n",c.per.student.student_number);`

### 应用二：创建含有不同类型数据的数据结构
利用联合使**数组元素是int型值和double型值的组合**

```c
typedef union{
    int i;
    float d;
}Number;

//接着创建数组
Number num_array[20];//数组元素是Number联合类型，而Number既可以是int,又可以是double
```

## 三、 联合的标记字段
联合面临的问题是：修改一个成员的值会让其他成员的值随之改变，我们不知道最后想要的成员是不是最后被改变的成员

- 现有一题：输出类型为Number的结构变量n中存储的值

    伪代码：

    ```
    void print_number(Number n){
        if(n包含一个整数)
          printf("%d",n.i);
        else
          printf("%f",n.f);
    }

    ```

    此时需要一个标记字段来**记录目前联合中存储的数的类型**，然后将联合嵌入结构中，通过标记字段判断联合的值

    ```c
    #define INT_TYPE 0;
    #define FLOAT_TYPE 1;

    /* 声明结构类型Number和联合类型num */
    typedef struct {
        int type;       /* 标记字段 */
        union{
            int i;
            float f;
        }num;/* 把上面那个联合定义了一个对象，名字叫 num,但num不是联合类型 */
    }Number;

    

    /* 假如有结构变量,要对num的成员i进行赋值运算 */
    Number n;
    n.type=INT_TYPE;   /* 提示修改的是整数 */
    n.num.i=996;

    /* 假如需要输出存储在联合变量u的整数时，可以通过type判断哪个成员是有效的 */
    /* 函数num_print */
    void print_number(Number v){
        if(v.type==INT_TYPE){
          printf("%d\n",v.u.i);
        }
        else
          printf("%f",v.u.f);
    }
    ```

---

# 枚举
将变量或对象可能存在的情况（可能的值）一一列举出来

## 一、 声明枚举型
- 三种：
    1. 直接声明（与结构，联合类似）
    2. 用枚举标记声明
    3. 用`typedef`定义枚举的类型名来声明变量

### 1.1 直接声明（与结构，联合类似）

- 对于`enum{PENCIL,PEN} box1;`,声明了枚举变量`box1`，内含两个枚举元素——`PENCIL`和`PEN`(也叫枚举常量，右值，但是能在声明的时候进行赋值操作)
- 注意，与结构和联合不同的是：枚举常量的名字必须不同于作用域范围内声明的其他标识符
- 在系统内部，C语言会把枚举变量和常量作为整数来处理。默认情况下，编译器会按0，1，2，···赋给枚举常量，如：
在`box1`例子中，`PENCIL,PEN`分别表示0、1
- 可以为枚举常量自由选择不同的值：
`enum Box {PENCIL=3,PEN=4};`
- 没有为枚举常量指定值时，它的值比前一个常量值大1

### 1.2 用枚举标记声明
与结构和联合类似：

```c
/* 定义枚举标记Box */
enum Box {PENCIL,PEN};
```

声明枚举变量box1：`enum Box box1;`

### 1.3 用`typedef`定义枚举的类型名来声明变量

`typedef enum{PENCIL,PEN} Box;`

声明枚举变量：`Box s1,s2;`


## 二、 用枚举声明标记字段
对于联合、三、的问题，用枚举更好，避免使用宏定义，可以更方便确定联合中最后一个被赋值的成员

- 在结构Number中，把成员type声明为枚举而不是int类型变量

```c
typedef struct {
        enum {INT_TYPE,FLOAT_TYPE}type;    /* 标记字段 */
        union{
            int i;
            float d;
        }u;
    }Number;
```



















---
尚未整理

# 程序结构 

### 作用域（scope）
- 变量的作用域系指该变量生效的范围。
- 在范围内，变量对其后的所有程序实体可见的(visible)，是可访问的(accessible) 
- 在此范围之外(之前、之后)变量对其他程序实体是不可见的(invisible)、不可访问的（inaccessible)。  
### 存储期  
- 指保持该变量的存储的最短潜在生命周期  
  
| 存储期            | 存储在何地，何时分配和释放                                                                 |
|-------------------|--------------------------------------------------------------------------------------------|
| 自动的 (automatic) | 在块开始时分配，块结束时释放。存储在栈（stack）中                                          |
| 静态的 (static)    | 存储在程序开始时分配，程序结束时释放。存储在**全局数据区**中                                   |
| 分配的 (allocated) | 存储是显式动态申请和释放的。存储在堆（heap）中                                             |
| 线程的 (thread)    | 存储在线程开始时分配，线程结束时释放                                                      |  
  

### 存储类别（storage class）
| 关键字      | 示例            | 变量的存储期   | 可以修饰                     |
|-------------|------------------|----------------|------------------------------|
| auto        | auto int i;      | automatic      | 局部变量，排除形参          |
| register    | register int i;  | automatic      | 局部变量和形参              |
| static      | static int i;    | static         | 局部和全局变量，排除形参    |
| extern      | extern int i;    | static         | 全局变量                    |


### 具有自动存储期的变量
| 声明 / 定义在哪里                                      | 作用域                       | 生命周期                                           |
|--------------------------------------------------------|------------------------------|---------------------------------------------------|
| 所有定义在一对 `{ }` 之间、没有用 `static` 修饰的变量 | 自其定义处至该块结束        | 退出该作用域时变量失效                           |
| 函数的形式参数                                         | 该函数的函数体              | 函数调用开始到函数返回，函数结束后参数失效       |
| `for` 语句初始化部分定义的变量                        | 该条 `for` 语句的语句块内   | `for` 循环结束时，该变量失效                     |  

### 具有静态存储期的变量  


| 分类                 | 特征内容                                                                 |
|----------------------|--------------------------------------------------------------------------|
| **静态的局部变量**   | - 定义在 `{}` 内部<br> - 使用 `static` 关键字修饰，如 `static int i = 0;`（一般需初始化）<br> - 仅初始化一次，若未显式初始化，按0初始化<br> - 生命周期为整个程序运行期间<br> - 保留上一次的计算结果，直到被再次修改 |
| **静态的非局部变量** | - 定义在所有函数之外，也称为全局变量<br> - 可加或不加 `static` 修饰<br> - 从定义处开始，对其后的所有代码可见<br> - 若某个函数修改了该变量，其改变对所有函数生效 |  

```c
/*var-static.c*/  

```  

![](./img/mask.jpg) 

### 链接属性 (Linkage)

| 链接属性 (Linkage)     | 显现形式 (Where It Appears)                        | 备注 (说明)                                               |
|-------------------------|----------------------------------------------------|-----------------------------------------------------------|
| 未设置 (none)           | - 局部变量（包括静态局部变量）<br> - 函数形参      | - 仅在定义它的代码块中可见和使用                         |
| 内部的 (internal)       | - `static` 修饰的全局变量<br> - `static` 修饰的函数 | - 仅在本源文件中可用<br> - 若在其他源文件访问将导致链接错误 |
| 外部的 (external)       | - `extern` 修饰的全局变量<br> - `extern` 修饰的函数 | - 可以被其他源文件访问和使用（具有外部链接性）           |  

| 性质       | 可见范围              | 常见修饰符       | 举例                  |
| -------- | ----------------- | ----------- | ------------------- |
| none     | 当前块 `{}` 内        | 无           | 函数内定义的变量            |
| internal | 当前源文件 `.c/.cpp` 内 | `static`    | `static int x = 0;` |
| external | 可跨源文件访问           | `extern`、默认 | 全局变量、非 static 函数    |  

### 堆栈

![](./img/堆栈.jpg)  

- 压栈:`void push(int i);`   
- 弹栈：`int pop();`   
- 判栈满：`bool is_full();` 
- 判栈空：`bool is_empty();`

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// 定义栈最大深度
#define STACK_SIZE 100

// 用一维数组模拟栈的存储
int contents[STACK_SIZE];
// 栈顶指针
int top = 0;

/**
 * @brief 栈溢出，退出程序
 */
void stack_overflow() {
    printf("Stack Overflow\n");
    exit(EXIT_FAILURE);
}

/**
 * @brief 栈空，退出程序
 */
void stack_underflow() {
    printf("Stack is empty\n");
    exit(EXIT_FAILURE);
}

/**
 * @brief 判断栈是否满
 * @return true 栈满
 * @return false 栈未满
 */
bool is_full() {
    return top == STACK_SIZE; 
}

/**
 * @brief 判断栈是否空
 * @return true 栈空
 * @return false 栈未空
 */
bool is_empty() {
    return top == 0;
}

/**
 * @brief 压栈
 * @param i 待压栈的元素
 */
void push(int i) {
    if (is_full())    // 如果栈满
        stack_overflow();
    else
        contents[top++] = i;
}

/**
 * @brief 弹栈
 * @return int 弹出的元素
 */
int pop() {
    if (is_empty())   // 如果栈空
        stack_underflow();
    else
        return contents[--top];
}

/**
 * @brief 测试函数
 */
int main() {
    for (int i = 0; i < 5; ++i) 
        push(i);    // 压栈 0,1,2,3,4

    int v = pop();   // 弹出4
    printf("%d, %d\n", v, pop()); // 输出 4, 3

    return 0;
}
``` 

```c
// 常规字符串字面常量
printf("To be or not to be, it's a question.");
```