

### 一、为什么大型程序必须拆成多个文件？
一个小作业可以用 1 个 .c 文件搞定，但真实项目动辄几万、几十万行代码，必须拆！

| 文件类型      | 后缀   | 作用                                     | 是否参与独立编译 |
|---------------|--------|------------------------------------------|------------------|
| 源文件（实现）| .c     | 写真正的函数体、变量定义                 | 是（每个 .c 是一个编译单元） |
| 头文件（接口）| .h     | 只放声明、宏、类型，不放实现             | 否（只是被 #include 进来）   |
| 目标文件      | .o/.obj| 编译后生成的中间文件                     | 中间产物         |
| 可执行文件    | .exe / 无后缀 | 最终能运行的程序                  | 最终产物         |

### 二、单文件 vs 多文件 构建过程对比（超级重要！）

| 项目           | 单文件程序                              | 多文件程序                                      |
|----------------|-----------------------------------------|-------------------------------------------------|
| 源文件         | 只有一个 main.c                        | main.c + student.c + utils.c + …                |
| 编译           | gcc main.c                              | gcc main.c student.c utils.c                    |
| 产生目标文件   | main.o                                  | main.o  student.o  utils.o …                    |
| 链接           | 链接器把 main.o + 标准库 → a.exe        | 链接器把所有 .o + 标准库 → 可执行程序            |
| 推荐方式       | 适合 200 行以内的小作业                | 真实项目全部都用这种方式                        |

### 三、头文件到底是干嘛的？——“接口与实现分离”

经典例子：学生信息管理系统

| 文件           | 内容                                            | 说明                                      |
|----------------|-------------------------------------------------|-------------------------------------------|
| student.h      | typedef struct {...} Student;<br>void print_student(Student s); | 只声明，不实现（只有函数原型）            |
| student.c      | #include "student.h"<br>void print_student(Student s) { …实现… } | 真正的函数体写在这里                      |
| main.c         | #include "student.h"<br>int main() { Student s; print_student(s); } | 使用者只需要 #include 头文件就行         |

好处：
- main.c 不需要看到 print_student 怎么实现的（降低耦合）
- student.c 可以单独编译测试
- 以后 100 个文件都要用 Student 类型，只需要 #include "student.h" 一次

### 四、#include 的两种写法区别（面试常考）

| 写法                  | 搜索顺序                              | 典型用途                         |
|-----------------------|---------------------------------------|----------------------------------|
| `#include <stdio.h>`    | 只在系统目录（编译器自带目录）找     | 标准库头文件                     |
| `#include "student.h"`  | 先在当前目录找 → 找不到再去系统目录找 | 自己写的头文件（99% 用这个）     |

### 五、头文件里能放什么？不能放什么？（铁律！）

**能放（推荐放）：**
- 宏定义        `#define MAX 100`
- 类型定义      `typedef struct Node Node;`
- 函数声明      `void push(Node** head, int val);`
- extern 变量声明   `extern int count;`
- 条件编译、头文件保护（后面讲）

**绝对不能放：**
- 普通全局变量定义   `int count = 0; `         → 会导致多重定义错误！
- 函数实现（函数体）  `void f() { … }`           → 同上！只会留声明

### 六、头文件保护（防止重复包含）—— 必须写！

标准写法（三行防护，背下来）：

```c
// student.h
#ifndef STUDENT_H           // 如果还没有定义 STUDENT_H
#define STUDENT_H           // 就定义它

// 这里放所有头文件内容
typedef struct { ... } Student;
void print_student(Student s);

#endif                      // 结束 ifndef
```

或者更现代的（C99 起支持）：
```c
#pragma once                // 放在文件最上面一行就行，很多IDE都认
```

### 七、真实项目中常见的文件组织（标准布局）

```
MyProject/
├── include/          → 放所有 .h（有的项目叫 headers）
│   ├── student.h
│   └── list.h
├── src/              → 放所有 .c 文件（source 的缩写）
│   ├── student.c
│   ├── list.c
│   └── main.c
├── build/            → 编译生成的 .o 和可执行文件
└── Makefile / CMakeLists.txt
```

### 八、怎么编译多文件项目？四种方式（从简单到专业）

| 方式               | 命令或操作                                      | 适合场景                     |
|-------------------|-------------------------------------------------|------------------------------|
| 1. 手动敲命令行   | `gcc main.c student.c utils.c -o myprog `         | 小项目，快速测试             |
| 2. 通配符        | `gcc *.c -o myprog`                               | 文件不多的时候              |
| 3. IDE 一键构建   | Visual Studio / CLion / Code:`:Blocks` → 点“运行” | 学生、上班摸鱼首选           |
| 4. Makefile（强烈推荐） | `make`                                          | 真实项目必备                |
| 5. CMake（跨平台神器） | `cmake . && make`                                | 大型、跨平台项目必备        |

- 最简单的 Makefile 模板（直接复制能用）：

```makefile
target = myprogram
sources = *.c

all:
	gcc $(sources) -o $(target)

clean:
	rm -f $(target) *.o
```


### 九、总结口诀（背下来这节课就满分）

```
一个项目多个 .c，  
头文件 .h 把接口给，  
实现放进 .c 里面，  
使用只要 #include，  
#ifndef 防重复，  
#pragma once 更简洁，  
gcc *.c 直接编，  
Makefile 真好使！
```

看完这篇整理，你现在已经完全掌握：
- 为什么大型程序必须拆文件
- 头文件的作用和正确写法
- 接口与实现分离的精髓
- 多文件如何编译（4种方式）
- 头文件防护

