# 函数
### 一、 函数的定义  
**形式如下 ：**  

```c
返回类型 函数名（形式参数parameter列表）//返回类型是指函数返回值的数据类型。如果函数无返回值，则返回类型为void类型
//形式参数列表可以为空
//这个部分也叫函数原型/签名（signature）
/*返回值是void时不能让函数参与赋值运算，同时可以没有return
有类型的话必须有return*/
{
    函数体
}
```

**示例如下：**  

```c
double max(double a,double b)
{
    return a>b?a:b;
}
```  

```c
/*求和
求出1到10、20到30和35到45的三个和*/  
#include<stdio.h>
//先声明一个求和函数
void sum(int begin,int end)
{
    int i;
    int sum = 0;
    for(i = begin;i <= end;i++){
        sum += i;
    }
    printf("sum = %d\n",sum);
}

//主函数
int main(){
    sum(1,10);
    sum(20,30);
    sum(35,45);

    return 0;
}

```

### 二、 函数的声明  
在调用函数前，必须先对函数进行声明  
示例：  

```c
#include<stdio.h>
double max(double a,double b);//①先声明，只需要有函数签名，不一定要有参数名称

int main()
{
    double x,y,m;
    printf("Enter two numbers:\n");
    scanf("%lf%lf",&x,&y);
    m = max(x,y);//②后调用
    printf("The maximum number is %f\n",m);
    return 0;
}

double max(double a,double b)
{
    return a>b?a:b;
}//③这是函数的定义
```

运行结果：
![](./img/函数声明.png)

### 三、 函数的参数
#### 3.1. 函数的传递（传值调用Call by value）  
- 参数传值只是把实际参数（argument）**复制**给形式参数，因此调用过程中形式参数parameter的改变不会影响到实际参数  

- 函数调用结束，返回主调函数后，形式参数变量的内存空间被回收，不复存在

#### 3.2. 指针型参数（out参数）//用于返回值不止一个

##### 3.2.1 作为参数
* 编写一个函数，能把两个参数的值互换  
  
如果这样写：

```c
#include<stdio.h>
void swap(int x,int y)
{
    int t;
    t = x;
    x = y;
    y = t;
}

int main()
{
    int a = 6,b = 8;
    printf("a=%d,b=%d\n",a,b);

    swap(a,b);
    printf("a=%d,b=%d\n",a,b);
    return 0;
}
```  

运行结果：

![](./img/交换参数.png)  

- **为了访问主调函数变量的值，必须向函数传递指向你希望修改的变量的指针，接着间接访问，修改主调函数变量的值**  

做出如下修改：  

```c
#include<stdio.h>
void swap(int *x,int *y)
{
    int t;
    t = *x;
    *x = *y;
    *y = t;
}

int main()
{
    int a = 6,b = 8;
    printf("a=%d,b=%d\n",a,b);

    swap(&a,&b);//实参和形参指针同时指向a,b。形参指针改变其指向的值，实参指针指向的值爷改变，但实参（即&a,&b）不改变
    //所以实参值要改变，形参必须是指针
    printf("a=%d,b=%d\n",a,b);
    return 0;
}
```
结果：  

![](./img/换参修改.png)

**用const保护参数**

```c
void f(const int *p) {
    *p = 0; //错误！
}
/* 指针参数p指向的单元被冻结，不能改变
但p仍然是变量，可以改变
注意：p改变后，将不再指向原来的单元！
 */
```

##### 3.2.2 作为返回值
#### 4.1. 指针作为返回值

```c
/* 正确写法 */
int * f(int *a) 
{ return a; }

int a = 1;
int *p = f(&a); //此后p指向a

/* 错误写法 */
int * f() { 
    int b = 1; 
    return &b; } //错误！

int *p = f(); 
/*此后p指向失效单元！

函数返回后，指针指向的单元必须有效！*/


```

#### 3.3. 数组型参数

```c
/* bubble3.c */
/* 改写bubble为函数，提高可重复利用性 */
# include<stdio.h>
# define N 10
void bubble(int a[],int n);
/*声明函数时，不指定它的长度是合法的，
因为：函数并没有为数组元素分配内存，而是间接访问主调函数中的数组元素*/

/* 主函数 */
int main(void){
    int arr[N] = {1,10,5,7,4,6,1,12,3,4};

    bubble(arr,N);

    //直接打印函数处理后的数组
    for(int m = 0;m < N;m++)
    printf("%3d",arr[m]);

return 0;
}

//定义函数
void bubble(int a[],int n){
    int t,i,j,flag = 1;

    for(i = 0;i < n - 1 && flag==1;i++){
    flag = 0;//暂时没有交换
        for(j = 0;j < n-1-i;j++){
        if(a[j]>a[j+1]){
        t = a[j];
        a[j] = a[j+1];
        a[j+1] = t;
        flag = 1;}
        }
    }
}

```




### 四、函数的调用  
#### 4.1 阶乘

```c
/* recursion.c */
#include<stdio.h>
unsigned long fact(unsigned long n);//声明,注意加;
int main(void){
    unsigned long m;
    printf("Enter a positive integer number:");
    scanf("%lu",&m);
    printf("%lu",fact(m));//调用

    return 0;
} 
//定义
unsigned long fact(unsigned long n){
    if(n <= 1) return 1;
    else return fact(n-1) * n;
}
```

#### 4.2 斐波那契数列
```c
/* fibnumber.c */
#include <stdio.h>
//声明+定义
unsigned long fibo(int n) {
    if(n <3)return 1;
    return fibo(n-1) + fibo(n-2);
   
}

int main() {

    int m;
    printf("Enter a number:");
    scanf("%d", &m);
    printf("%lu\n", fibo(m));//调用

    return 0;
}

```

#### 4.3 选择排序


```c
/* selection.c要求将整数数组排序 */
#include<stdio.h>
#define N 10
void selection_sort(int a[],int n);//声明

int main(void){
    int a[N],i;
    printf("Enter %d numbers to be sorted:",N);
    for(int i = 0; i < N ; i++){
        scanf("%d",&a[i]);
    }
    selection_sort(a,N);//调用

    printf("In sorted order:");
    for(i=0;i<N;i++){
        printf(" %d",a[i]);
    }
    printf("\n");
    return 0;
}

//定义
void selection_sort(int a[],int n){
    int i, largest = n-1 , temp;//默认把最后一个元素当做当前“最大值”的位置
    
    if(n == 1)
    return;

    for(i = 0;i < n;i++){
        if(a[i] > a[largest])
          largest = i;
    }//扫描每个元素，定位最大值到largest(即i)
    if(largest < n-1){
        temp = a[n-1];
        a[n-1]=a[largest];
        a[largest]=temp;
    }//通过让最大值所在位置元素与最后一个元素交换，确保最大值在放在最后

    selection_sort(a,n-1);//对剩下前n-1个元素做相同处理
}
```


结果
> Enter 10 numbers to be sorted:10 20 50 12 78 46 25 78 36 33
> In sorted order: 10 12 20 25 33 36 46 50 78 78

### 五、C 语言中的栈（Stack）总结

#### 5.1. 什么是栈（Stack）

栈是 C 程序运行时由系统自动管理的一块内存区域，用来存放：

* 函数的返回地址
* 函数参数
* 局部变量
* 临时数据（如表达式求值时的临时变量）

其核心特点是：

* **后进先出（LIFO — Last In, First Out）**

---

#### 5.2. 栈相关术语

##### **5.2.1 压栈（Push）**

把数据**放入栈顶**。

触发场景包括：

* 调用函数时压入**返回地址**
* 将**函数参数**压栈
* 给**局部变量分配空间**（等价于压栈）

---

##### **5.2.2 出栈 / 弹栈（Pop）**

把栈顶的数据**移出栈**。

函数结束时会自动执行：

* 弹出局部变量
* 弹出参数
* 弹出返回地址并跳回原位置

---

#### 5.3. 栈的结构图示（简化）

函数调用：`fun(5, 10)` 时栈可能如下：

```
|--------------------|
| 返回地址           |
| 参数10             |
| 参数5              |
| 局部变量           |
|--------------------|
```

函数结束后，以上内容依次**出栈**。

---

#### 5.4. 示例：函数调用过程中的压栈与出栈

```c
#include <stdio.h>

void bar(int x) {
    int b = 20;
    printf("bar: x = %d, b = %d\n", x, b);
}

void foo(int a) {
    int y = 10;
    bar(a + y);
}

int main() {
    int n = 5;
    foo(n);
    return 0;
}
```

##### 调用过程说明（简要）

* `main()` 调用 `foo()` → **压栈**
* `foo()` 调用 `bar()` → **压栈**
* `bar()` 结束 → **出栈**
* `foo()` 结束 → **出栈**
* `main()` 结束 → **出栈**

---

#### 5.5. 自己实现一个简单的“栈结构”

虽然 C 不允许直接操作系统栈，但我们可以通过数组模拟一个栈：

```c
#include <stdio.h>

#define MAX 100

int stack[MAX];
int top = -1;   // 栈顶指针

void push(int x) {
    if(top == MAX - 1) {
        printf("栈满！\n");
        return;
    }
    stack[++top] = x;
}

int pop() {
    if(top == -1) {
        printf("栈空！\n");
        return -1;
    }
    return stack[top--];
}

int main() {
    push(10);
    push(20);
    push(30);

    printf("弹栈: %d\n", pop()); // 30
    printf("弹栈: %d\n", pop()); // 20
    printf("弹栈: %d\n", pop()); // 10

    return 0;
}
```

输出：

```
弹栈: 30
弹栈: 20
弹栈: 10
```

体现了典型 **LIFO** 行为。

---

#### 5.6. 快速记忆总结表

| 名称      | 含义             | 触发场景           |
| ------- | -------------- | -------------- |
| 栈       | 程序运行时自动管理的内存区域 | 存放局部变量、参数、返回地址 |
| 压栈 push | 往栈顶放数据         | 函数调用、传参、创建局部变量 |
| 出栈 pop  | 从栈顶取数据         | 函数返回时          |
| 特点      | 后进先出（LIFO）     | 系统自动管理，无需手动释放  |

---
#### 5.7. 栈（Stack） vs 堆（Heap）对比

| 项目    | 栈（Stack）           | 堆（Heap）                     |
| ----- | ------------------ | --------------------------- |
| 管理方式  | 系统自动分配和释放          | 程序员手动申请 / 释放（malloc / free） |
| 分配速度  | **快（系统指针移动即可）**    | **较慢（需要管理复杂结构）**            |
| 存储内容  | 局部变量、函数参数、返回地址     | 动态分配的数据                     |
| 生命周期  | 作用域结束即自动释放         | free() 或进程结束才释放             |
| 内存大小  | 较小（固定大小，如 1MB~8MB） | 较大（系统剩多少就有多少）               |
| 访问方式  | 连续内存，CPU 直接访问      | 不连续，需要维护指针                  |
| 易出现问题 | 栈溢出（深递归/过大局部数组）    | 内存泄漏、野指针                    |

---

#### 5.8. 递归函数的栈增长示例

以经典递归函数为例：

```c
int f(int n) {
    if(n == 1) return 1;
    return n + f(n - 1);
}
```

调用 `f(4)` 时栈的变化：

```
f(4)
└─ f(3)
   └─ f(2)
      └─ f(1)
```

##### 栈帧展开图（调用时不断压栈）

```
|-------------------|
| f(1) 栈帧         | ← 最后压入
|-------------------|
| f(2) 栈帧         |
|-------------------|
| f(3) 栈帧         |
|-------------------|
| f(4) 栈帧         | ← 最先压入
|-------------------|
```

##### 执行结束时出栈顺序（从栈顶开始）

```
返回 f(1) → 弹出 f(1) 栈帧
返回 f(2) → 弹出 f(2) 栈帧
返回 f(3) → 弹出 f(3) 栈帧
返回 f(4) → 弹出 f(4) 栈帧
```

**递归每调用一次，就会产生一个新的栈帧。**

---



一个函数在执行时，在栈中开辟的一块连续区域称为：

#### 5.9.👉 栈帧（Stack Frame）

每个栈帧通常包含：

```
|--------------------------|
| 返回地址                |
|--------------------------|
| 上一个栈帧的指针 (EBP) |
|--------------------------|
| 函数参数                |
|--------------------------|
| 局部变量                |
|--------------------------|
| 临时变量                |
|--------------------------|
```

下面是一个例子：

```c
int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = 10;
    int y = 20;
    int c = add(x, y);
}
```

##### 当执行到 `add(x, y)` 时，add 的栈帧大致结构：

```
|---------------------------|
| 返回地址（回 main）      |
|---------------------------|
| 上一帧指针（main 的基址）|
|---------------------------|
| 参数 a = 10              |
| 参数 b = 20              |
|---------------------------|
| 局部变量 result          |
|---------------------------|
```

函数结束后：

* 栈指针上移 → 栈帧被销毁
* CPU 跳回保存的返回地址继续执行 main()

整套流程自动完成，无需程序员干预。

---

#### 5.10. 栈帧图（更直观）

```
main() 调用 add(10, 20)

栈顶 ↓
|-------------------------------|
| add 的局部变量 result         |
| 参数 b = 20                   |
| 参数 a = 10                   |
|-------------------------------|
| 返回地址（回到 main）         |
| main 的局部变量 x, y, c      |
|-------------------------------|
栈底 ↑
```

---

#### 5.11. 为什么栈是“后进先出”（LIFO）

因为函数调用是 **嵌套进行** 的：

* 调用 A 时 → 压入 A 的信息
* A 调用 B 时 → 压入 B 的信息
* 必须先让 B 完成才能继续 A

因此：

```
调用顺序：A → B
返回顺序：B → A
```

这就是典型的 **LIFO（后进先出）**。

---

#### 5.12. 栈溢出的经典原因（面试常考）

* 递归太深（如无退出条件的递归）
* 定义了巨大的局部数组：

```c
int a[10000000]; // 在栈上，可能直接炸
```

这种应该放到堆上：

```c
int *a = malloc(10000000 * sizeof(int));
```

---
### 六、变量的存储形式
#### 6.1 register变量(寄存器变量)
- 可以将循环控制变量和频繁用到的变量定义为register变量

```c
/* register.c 把变量放在fac（阶乘）函数中 */
#include<stdio.h>
int fac(int n){
    register int i,f = 1;
    for(i=2;i<=n;i++)
        f=f*i;
        return (f);
}
int main(){
    int i;
    for(i=1;i<=10;i++)
    printf("%d!=%d\n",i,fac(i));
}

```

结果
>1!=1
>2!=2
>3!=6
>4!=24
>5!=120
>6!=720
>7!=5040
>8!=40320
>9!=362880
>10!=3628800

- 只有局部变量才能定义为register变量，但不能定义过多，一般不超过3个（由于register变量不在内存内，因此不能进行地址运算）


```c
regiater int k;
scanf("%d",&k);/* 错误 */
```

#### 6.2 extern变量

如果a.c里面需要引入b.c中的变量v，就可以在a.c中任何地方声明`extern int v`




















---
以下还未整理

2.  编写一个函数求参数n的阶乘。函数原型：  
`typedef unsigned long ULONG;`
`ULONG fact(ULONG n);`

```c
#include <stdio.h>

// 定义本程序用到的数据类型
typedef unsigned long ULONG;
ULONG fact(ULONG n) {
    // TODO
    ULONG f = 1;
    for(ULONG i = 2;i <= n;++i)
        f *= i;
        return f;
    // END
}

int main() {
    ULONG n;

    scanf("%lu", &n);
    printf("%lu\n", fact(n));//printf先执行，遇到fact函数就暂停

    return 0;
}
```  

3. 编写一个函数求fibonacci数列的第n项。  

```c
#include <stdio.h>

// 定义本程序用到的数据类型
typedef unsigned long ULONG;
ULONG fibo(ULONG n) {
    // TODO
    ULONG fn,fn1,fn2;

    fn = fn1 = fn2 = 1;
    for(ULONG i = 3;i <= n;++i){
        fn = fn1 + fn2;
        fn2 = fn1;
        fn1 = fn;
        
    }
    return fn;

    // END
}

int main() {
    ULONG n;

    scanf("%lu", &n);
    printf("%lu\n", fibo(n));

    return 0;
}
```   

#### 函数的递归调用  

1. **结构：**

```c
f(){
    ...
    f();
    ...
}//没有条件的递归是个死循环，所以递归应该有条件限制
```  

```c
f(){
    ...
    if(...)f();
    ...
}
```   

2. 应用

```c/*fact*/
#include <stdio.h>

// 定义本程序用到的数据类型
typedef unsigned long ULONG;
ULONG fact(ULONG n) {
    
    if(n == 1)return 1;
    return n * fact(n - 1);

}

int main() {
    ULONG n;

    scanf("%lu", &n);
    printf("%lu\n", fact(n));

    return 0;
}  
```  

```c
#include <stdio.h>

// 定义本程序用到的数据类型
typedef unsigned long ULONG;

ULONG fibo(ULONG n) {
    // TODO 
    if(n <3)return 1;
    return fibo(n-1) + fibo(n-2);
    // END
}

int main() {
    ULONG n;

    scanf("%lu", &n);
    printf("%lu\n", fibo(n));

    return 0;
}
```

![](./img/递归调用.jpg)  

3. 汉诺塔问题

```c
#include<stdio.h>

void hanoi(int n,char A,char B,char C){
    if(n = 1){
        printf("%c ---> %c\n",A,B);
        return ;
    }

    hanoi(n-1,A,C,B);
    hanio( 1, A,B,C);
    hanio(n-1,C,B,A);
}

int main(){
    int n;
    char A,B,C;
    scanf("%d",&n);
    hanio(n,'A','B','C');

    return 0;
}
```




### 数组型参数  

### 关于一些细节  
*1.*`void f(void);`和`void f();`有没有区别

```c
void swap();
//原型不确定是谁，编译通过，但编译器猜测swap要两个int

int main(){ 
    int a = 5; 
    int b = 6; 
    swap(a,b); 
    {
        int a = 0; 
        printf("a=%d\n",a);
    } 
    printf("a=%d, b=%d\n", a, b); 
    return 0;
} 
void swap(double a, double b)
//这里又在定义函数时把参数设置成double
{
    int swap;
    int t = a;
    printf("in swap,a = %f,b = %f\n",a,b);
    a = b;
    b = t;
}
```

结果
> in swap,a = 0.000000,b = 0.000000
> a=0
> a=5, b=6

```c
void swap(void);
//不知道参数时最好加上void

int main(){ 
    int a = 5; 
    int b = 6; 
    swap(a,b); 
    {
        int a = 0; 
        printf("a=%d\n",a);
    } 
    printf("a=%d, b=%d\n", a, b); 
    return 0;
} 
void swap(double a, double b)
{
    int swap;
    int t = a;
    printf("in swap,a = %f,b = %f\n",a,b);
    a = b;
    b = t;
}
```

*2*.调用函数时用的,和,运算符的区别
```c
f(a,b)
//传了两个参数
f((a,b))
//先做逗号运算，算出的结果进行传递
```

*3*.函数里面不能再定义另一个函数，可以放另一个函数的声明，但是不能放它的body

---

