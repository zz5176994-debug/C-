# 指针  
**作用**：存储变量地址  
  
  ---  
  ## 一. 指针变量及应用  
  ### 1.简单赋值  
  ```c  
  int a = 5;
  int *p = &a;
  printf("%d %d\n",a,*p);  
  ```  

  **注意**：指针的占位符为%p；如  
  ```c
  int a = 5;
  int *p = &a;
  printf("%d %p\n",a,p);  
  ```
*结果*
  > 5 000000000061FE44  
  ### 2. 长度  
  任何类型的指针长度都是一样的  
  （64位机$\rightarrow$指针占8个字节  
  32位机$\rightarrow$4个字节）  

  ***有两种含义**  
  * 定义的时候：表示指针  
  * 使用的时候：表示取值（取指针指向的空间的内存）所以*p就是变量a   
  ` *p=100      //把a的值改成100 `  
  ### 3. 不同类型  
  1. int*  

  ```c  
    int  num = 1;
    int *p = &num;
  ```  

  2. char*  
  ```c  
    char ch = 'a';
    //int *q = &ch;   //类型不兼容   
    char *q = &ch;
    *q = 'x';
    printf("%c\n",ch);
  ```  
  3. int *和 char *的不同  
    步数（长度）+1的结果不同  
```c  
    printf("%p\n",p+1);  //p指向的是整数，整数占4字节，所以p+1加4字节
    printf("%p\n",q+1);  //q指向的是字符，字符占1字节，所以q+1加1字节  
```   
### 4. 空指针和野指针  
```c   
int *p;
*p = 100;  //段错误：访问了不能访问的内存
```  
* 如何合法使用内存  
  1. 系统分配的内存
     
```c
int a;
int *p = &a;
```


  ii. 用户申请内存$\rightarrow$堆内存（用malloc函数）


```c
char *str = (char *)malloc(32);
free(str);  //释放内存，如果不释放会造成内存泄露
str = NULL;  //释放后还需要让他置为空指针，否则会变成野指针
/*NULL表示指针不指向任何有效数字
可以将指针与0比较来判断其是否为NULL
通过*间接引用违背初始化的指针和值为NULL的指针会导致系统崩溃*/
```


---
  
## 二 、指针和数组
**数组名a相当于指向数组第一个元素的指针常量**
即`a[i]`和`*(a+i)`以及`&a[i]`和`a+i`等价  


### 2.1. 数组名作为指针

```c
/*因为数组名a相当于指向数组第一个元素的指针常量
常量不能修改，下面展示一种错误写法*/
while(*a!=0)
a++;
/*如果把a赋值给一个指针变量，那么就是合法的*/
p=a;
while(*a!=0)
a++;
```

### 2.2. 指针作为数组名
把`p[i]`看作`*(p+i)`

### 2.3 指针的比较
- 尽管值都是二进制正整数，但从关系运算的语义来看，允许不同类型的指针进行比较没有实际意义

---

## 三、指针和二维数组

### 3.1. 操作二维数组的行
- 指针访问语法


**（假设定义为：`int c[3][4]; int (*b)[4] = c;`）**
**在表达式中，数组c会退化为指向一行的指针**

|目标元素|数组下标写法|指针等价写法（基于数组名 c ）|指针等价写法（基于行指针 b ）|
|:-----:|:------:|:--------------:|:----------------:|
|第 i 行第 j 列| `c[i][j]` |`*(c[i] + j)`|` *(*(b + i) + j) `|
|第 i 行第 j 列  |` c[i][j]`|`*(*(c + i) + j)`|`(*(b + i))[j] `|
|第 0 行第 1 列|` c[0][1]`|`(*c)[1] （ c 指向第0行）`|`(*b)[1] （ b=c 时）`|
|第 1 行第 1 列|`c[1][1]`|`(*(c+1))[1] （ c+1 指向第1行）`|` (*(b+1))[1] （ b=c 时）`|


### 3.2. 操作二维数组的列

示例：访问每行中“列下标为1”的元素

```c
#include <stdio.h>
int main() {
    // 定义二维数组c（2行4列）
    int c[2][4] = {{1,2,3,4}, {11,12,13,14}};
    // 定义“指向数组的指针”b（指向长度为4的一维数组）
    int (*b)[4];

    // 遍历每一行：b从c[0]（第0行）指向c[2]（行的结束位置）
    for (b = c; b < c + 2; b++) {
        // (*b)代表当前行，(*b)[1]就是当前行的第1列元素
        printf("当前行第1列元素：%d\n", (*b)[1]);
    }
    return 0;
}
```


运行结果：

> 当前行第1列元素：2
> 当前行第1列元素：12



### 3.3. 指针数组+指向数组的指针
 


#### 🧩 3.3.1、先看定义区别

|    名称    |      定义示例      |              中文解释             |         含义        |
| :------: | :------------: | :---------------------------: | :---------------: |
| **指针数组** |  `int *a[5];`  |       “a 是一个数组，数组里放的是指针”      | 数组的每个元素是一个 `int*` |
| **数组指针** | `int (*p)[5];` | “p 是一个指针，指向一个有 5 个 int 元素的数组” |  指针指向一个 `int[5]`  |

---

##### 📘 理解口诀：

> **看右边最近的符号：**
>
> * `[]` 优先于 `*` → 说明它是**数组**（即“指针数组”）
> * `()` 把 `*` 括起来 → 说明它是**指针**（即“数组指针”）



#### 🧠 3.3.2、分别举例说明

##### ✅ 1. 指针数组（array of pointers）

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20, c = 30;
    int *arr[3] = { &a, &b, &c }; // 指针数组：数组的每个元素是指向 int 的指针

    for (int i = 0; i < 3; i++) {
        printf("arr[%d] = %p, *arr[%d] = %d\n", i, arr[i], i, *arr[i]);
    }

    return 0;
}
```

- 运行结果示例：

```
arr[0] = 0x7ffee..., *arr[0] = 10
arr[1] = 0x7ffee..., *arr[1] = 20
arr[2] = 0x7ffee..., *arr[2] = 30
```


🧭 **用途：**

* 常用于存放多个字符串的地址，例如 `char *argv[]`（命令行参数）。

---

##### ✅ 2. 数组指针（pointer to an array）

```c
#include <stdio.h>

int main() {
    int a[3] = {10, 20, 30};
    int (*p)[3] = &a; // 数组指针：p 指向一个含 3 个 int 的数组

    printf("(*p)[0] = %d\n", (*p)[0]);
    printf("(*p)[1] = %d\n", (*p)[1]);
    printf("(*p)[2] = %d\n", (*p)[2]);

    return 0;
}
```

- 运行结果：

```
(*p)[0] = 10
(*p)[1] = 20
(*p)[2] = 30
```


🧭 **用途：**

* 常用于二维数组访问，如：`int (*p)[4] = c;` 其中 `c` 是二维数组。

---

